# 1.3 Conceptos Fundamentales de los Contenedores

## Conceptos Clave

## Imágenes
## Slide 2
Si bien antes deciamos que un **contenedor** es un paquete ligero y portable que podremos usar para ejecutar nuestras aplicaciones. Ese contenedor, necesita acceso a ciertos recursos para que nuestra aplicación pueda correr, es decir:
- El código
- El runtime de nuestra aplicación
- Las herramientas y librerías del sistema que este mismo utilizará
- La configuración de la aplicación

Diremos por tanto que las imagenes son la plantilla o template que ese contenedor utilizara para poder lanzarse, es decir, el contenido que necesita para poder ejecutarse.

Tanto el codigo, como las librerias y la configuracion de la aplicacion, se encuentran en la imagen.

Una vez una imagen ha sido creada no podremos modificarla, solo podremos borrarla y crear una nueva imagen. 

Ademas, al lanzar un contenedor, este no modificara la imagen si no que creara una capa de escritura sobre la imagen original.

Por tanto diremos que la imagen es inmutable. 
## Slide 3

### Ejemplo: Aplicación PyTweets

Imaginemos que queremos un contenedor para nuestra aplicación de microblogging desarrollada en Python. Nuestra aplicación de microblogging se llamará **PyTweets**.

1. Usaremos una imagen base que podremos obtener online con Python ya preinstalado y todas sus herramientas comunes. Esta imagen la provee y mantiene el equipo oficial de Python. Imaginemos que esta imagen se llama `python-base:3.6`

2. A esta imagen base le agregaremos nuestro código y la configuración para nuestra aplicación, obtendremos la imagen de nuestro contenedor, a la que ahora sí, llamamos `PyTweets:1.0`

El resultado final será una **imagen dedicada para nuestra aplicación**.

## Slide 4

en futuras versiones de nuestra aplicacion, podremos crear nuevas versiones de nuestra imagen. Por ejemplo, la siguiente version sera `PyTweets:1.1` y la siguiente `PyTweets:1.2` y asi sucesivamente.


En este modelo, diremos que python-base:3.6, PyTweets es nuestra imagen , que 1.0, 1.1 y 1.2 son versiones de nuestra imagen.
## Slide 5

Podremos lanzar tantas copias de nuestra aplicación como queramos simplemente creando contenedores basados en esta imagen. El contenedor simplemente estará ejecutando un proceso de Python por cada contenedor que lancemos. El proceso correrá en el contexto de nuestra imagen, es decir, que tendrá acceso al código y la configuración.

Esto significa que podriamos tener contenedores de esta imagen corriendo en difrentes entornos, siendo exactamente la misma aplicacion, codigo y versiones de librerias o varias replicas en un mismo entorno, mejorando la disponibilidad de la aplicacion y doblando los recursos.


## Capas (Layers) y Filesystem CoW (Copy-on-Write)




### Capas de Imagen
Las imágenes de contenedores están compuestas por un conjunto de **capas de solo lectura apiladas**. Cada instrucción que le demos al software que se encarga de crear nuestra imagen a través del fichero de definición de imagen (`Dockerfile`), creará una nueva capa sobre la anterior.
## Slide 6
**Ventajas del diseño en capas:**

1. **Eficiencia:** Solo se modificará una capa cuando la orden haya sido modificada o cuando una capa anterior haya cambiado

2. **Reutilización:** Múltiples imágenes podrían compartir capas **cuando son idénticas** (mismo comando, mismo orden), ahorrando:
   - Espacio en disco
   - Tiempo de descarga de imágenes

## Slide 7
### Filesystem Copy-on-Write (CoW)

Cuando lanzamos un contenedor a partir de una imagen, el engine de contenedores hace una serie de tareas:

1. Obtiene la imagen base (solo lectura)
2. Agrega una **capa de escritura** donde el contenedor hará todas las operaciones de escritura:
   - Crear nuevos ficheros
   - Modificar ficheros existentes

De esta forma, un contenedor **nunca modificará el archivo de imagen original**, sino que irá añadiendo capas de disco según lo vaya necesitando.

**Beneficios:**

- **Alta eficiencia** en entornos donde los ficheros de imagen originales van a ser reutilizados
- **Ahorro de espacio en disco**
- **Mejor rendimiento** (no hace falta crear una copia completa de cada imagen por cada contenedor, como sí es habitual en entornos de máquinas virtuales, aunque también se puede usar un sistema parecido)

## Ciclo de Vida de un Contenedor

Un contenedor tiene un ciclo de vida simple:

1. **Creación:** Se crea una instancia de la imagen
2. **Ejecución:** El contenedor ejecuta su proceso principal
3. **Parada:** El proceso termina o lo paramos manualmente
4. **Eliminación:** Se elimina el contenedor

**Diferencia importante:** Cuando un contenedor se **pausa o detiene**, la capa de escritura (con los datos que ha generado) se mantiene. Sin embargo, cuando se **elimina**, esa capa desaparece y con ella todos los datos que el contenedor había escrito.

## Volúmenes: Almacenamiento Persistente

Como hemos visto, cuando un contenedor se elimina, se pierde la capa de escritura y todos los datos con ella. Para solucionar esto existen los **volúmenes**, que son espacios de almacenamiento **externo al contenedor** que persisten incluso cuando el contenedor se elimina.

**Ejemplo:** Imaginemos una base de datos ejecutándose en un contenedor. Si no usamos volúmenes y eliminamos el contenedor, perderíamos toda la base de datos. Con un volumen, la base de datos se almacena en un lugar externo (en el disco del host o en almacenamiento remoto) y persiste incluso si eliminamos el contenedor.

> **Nota:** Los volúmenes se cubrirán en detalle en el Módulo 2. Por ahora solo necesitas entender que existen y para qué sirven.

## Red y Puertos

Los contenedores están **aislados por defecto**, lo que significa que no pueden comunicarse directamente con otros contenedores ni con aplicaciones externas a menos que configuremos explícitamente esa comunicación.

Para que una aplicación dentro de un contenedor sea accesible desde fuera (por ejemplo, una aplicación web), necesitamos **mapear puertos**. Un mapeo de puertos conecta un puerto del contenedor con un puerto del host (máquina donde se ejecuta Docker), permitiendo que el tráfico externo llegue a la aplicación.

**Ejemplo:** Si tenemos una aplicación web escuchando en el puerto 8080 dentro del contenedor, podemos mapearla al puerto 3000 del host, de forma que accediendo a `localhost:3000` desde fuera, llegaremos a la aplicación dentro del contenedor.

> **Nota:** Las redes en contenedores se explorarán más profundamente en el Módulo 3. Por ahora solo necesitas saber que el aislamiento y el mapeo de puertos existen.

### ⚠️ Importante: Persistencia de Datos

Cuando el contenedor se elimina, la capa de escritura se pierde, por lo tanto **todos los datos que ese contenedor había escrito en disco también**.

Por eso es importante usar **volúmenes** cuando nuestros contenedores necesitan persistencia de datos (bases de datos, archivos, logs, etc.).
