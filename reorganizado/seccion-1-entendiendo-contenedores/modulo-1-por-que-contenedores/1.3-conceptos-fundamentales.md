# 1.3 Conceptos Fundamentales de los Contenedores

## Conceptos Clave

1. **Imágenes:** Plantillas inmutables de solo lectura
2. **Contenedores:** Instancias ejecutables de imágenes
3. **Capas (Layers):** Cómo se construyen las imágenes de forma eficiente
4. **Filesystem CoW (Copy-on-Write):** Optimización de espacio y rendimiento

## Contenedores e Imágenes

Como hemos dicho antes, diremos que un **contenedor** es un paquete ligero y portable que podremos usar para ejecutar nuestras aplicaciones. Tiene lo mínimo necesario para que nuestra aplicación pueda correr, es decir:
- El código
- El runtime de nuestra aplicación
- Las herramientas y librerías del sistema que este mismo utilizará
- La configuración de la aplicación

El contenido de un contenedor viene dado por su **imagen**. La imagen define qué habrá en el disco donde ese contenedor está ejecutándose. Ahí entra todo lo mencionado antes: el runtime, herramientas del sistema, librerías y la configuración.

### Ejemplo: Aplicación PyTweets

Imaginemos que queremos un contenedor para nuestra aplicación de microblogging desarrollada en Python. Nuestra aplicación de microblogging se llamará **PyTweets**.

1. Usaremos una imagen base que podremos obtener online con Python ya preinstalado y todas sus herramientas comunes. Esta imagen la provee y mantiene el equipo oficial de Python. Imaginemos que esta imagen se llama `python-base:3.6`

2. Sobre esta imagen base y tras agregarle nuestro código y configuración para nuestra aplicación, obtendremos la imagen de nuestro contenedor, a la que ahora sí, llamamos `PyTweets:1.0`

El resultado final será una **imagen dedicada para nuestra aplicación**.

Podremos ahora lanzar tantas copias de nuestra aplicación como queramos simplemente creando contenedores basados en esta imagen. El contenedor simplemente estará ejecutando un proceso de Python por cada contenedor que lancemos. El proceso correrá en el contexto de nuestra imagen, es decir, que tendrá acceso al código y la configuración.

## Capas (Layers) y Filesystem CoW (Copy-on-Write)

### Capas de Imagen

Las imágenes de contenedores están compuestas por un conjunto de **capas de solo lectura apiladas**. Cada instrucción que le demos al software que se encarga de crear nuestra imagen a través del fichero de definición de imagen (`Dockerfile`), creará una nueva capa sobre la anterior.

**Ventajas del diseño en capas:**

1. **Eficiencia:** Solo se modificará una capa cuando la orden haya sido modificada o cuando una capa anterior haya cambiado

2. **Reutilización:** Múltiples imágenes podrían compartir capas **cuando son idénticas** (mismo comando, mismo orden), ahorrando:
   - Espacio en disco
   - Tiempo de descarga de imágenes

### Filesystem Copy-on-Write (CoW)

Cuando lanzamos un contenedor a partir de una imagen, el engine de contenedores:

1. Obtiene la imagen (solo lectura)
2. Agrega una **capa de escritura** donde el contenedor hará todas las operaciones de escritura:
   - Crear nuevos ficheros
   - Modificar ficheros existentes

De esta forma, un contenedor **nunca modificará el archivo de imagen original**, sino que irá añadiendo capas de disco según lo vaya necesitando.

**Beneficios:**

- **Alta eficiencia** en entornos donde los ficheros de imagen originales van a ser reutilizados
- **Ahorro de espacio en disco**
- **Mejor rendimiento** (no hace falta crear una copia completa de cada imagen por cada contenedor, como sí es habitual en entornos de máquinas virtuales, aunque también se puede usar un sistema parecido)

## Ciclo de Vida de un Contenedor

Un contenedor tiene un ciclo de vida simple:

1. **Creación:** Se crea una instancia de la imagen
2. **Ejecución:** El contenedor ejecuta su proceso principal
3. **Parada:** El proceso termina o lo paramos manualmente
4. **Eliminación:** Se elimina el contenedor

**Diferencia importante:** Cuando un contenedor se **pausa o detiene**, la capa de escritura (con los datos que ha generado) se mantiene. Sin embargo, cuando se **elimina**, esa capa desaparece y con ella todos los datos que el contenedor había escrito.

## Volúmenes: Almacenamiento Persistente

Como hemos visto, cuando un contenedor se elimina, se pierde la capa de escritura y todos los datos con ella. Para solucionar esto existen los **volúmenes**, que son espacios de almacenamiento **externo al contenedor** que persisten incluso cuando el contenedor se elimina.

**Ejemplo:** Imaginemos una base de datos ejecutándose en un contenedor. Si no usamos volúmenes y eliminamos el contenedor, perderíamos toda la base de datos. Con un volumen, la base de datos se almacena en un lugar externo (en el disco del host o en almacenamiento remoto) y persiste incluso si eliminamos el contenedor.

> **Nota:** Los volúmenes se cubrirán en detalle en el Módulo 2. Por ahora solo necesitas entender que existen y para qué sirven.

## Red y Puertos

Los contenedores están **aislados por defecto**, lo que significa que no pueden comunicarse directamente con otros contenedores ni con aplicaciones externas a menos que configuremos explícitamente esa comunicación.

Para que una aplicación dentro de un contenedor sea accesible desde fuera (por ejemplo, una aplicación web), necesitamos **mapear puertos**. Un mapeo de puertos conecta un puerto del contenedor con un puerto del host (máquina donde se ejecuta Docker), permitiendo que el tráfico externo llegue a la aplicación.

**Ejemplo:** Si tenemos una aplicación web escuchando en el puerto 8080 dentro del contenedor, podemos mapearla al puerto 3000 del host, de forma que accediendo a `localhost:3000` desde fuera, llegaremos a la aplicación dentro del contenedor.

> **Nota:** Las redes en contenedores se explorarán más profundamente en el Módulo 3. Por ahora solo necesitas saber que el aislamiento y el mapeo de puertos existen.

### ⚠️ Importante: Persistencia de Datos

Cuando el contenedor se elimina, la capa de escritura se pierde, por lo tanto **todos los datos que ese contenedor había escrito en disco también**.

Por eso es importante usar **volúmenes** cuando nuestros contenedores necesitan persistencia de datos (bases de datos, archivos, logs, etc.).
