# 1.3 Conceptos Fundamentales de los Contenedores

## Conceptos Clave

## Imágenes
## Slide 2
Si bien antes deciamos que un **contenedor** es un paquete ligero y portable que podremos usar para ejecutar nuestras aplicaciones. Ese contenedor, necesita acceso a ciertos recursos para que nuestra aplicación pueda correr, es decir:
- El código
- El runtime de nuestra aplicación
- Las herramientas y librerías del sistema que este mismo utilizará
- La configuración de la aplicación

Diremos por tanto que las imagenes son la plantilla o template que ese contenedor utilizara para poder lanzarse, es decir, el contenido que necesita para poder ejecutarse.

Tanto el codigo, como las librerias y la configuracion de la aplicacion, se encuentran en la imagen.

Una vez una imagen ha sido creada no podremos modificarla, solo podremos borrarla y crear una nueva imagen. 

Ademas, al lanzar un contenedor, este no modificara la imagen si no que creara una capa de escritura sobre la imagen original.

Por tanto diremos que la imagen es inmutable. 
## Slide 3

### Ejemplo: Aplicación PyTweets

Imaginemos que queremos un contenedor para nuestra aplicación de microblogging desarrollada en Python. Nuestra aplicación de microblogging se llamará **PyTweets**.

1. Usaremos una imagen base que podremos obtener online con Python ya preinstalado y todas sus herramientas comunes. Esta imagen la provee y mantiene el equipo oficial de Python. Imaginemos que esta imagen se llama `python-base:3.6`

2. A esta imagen base le agregaremos nuestro código y la configuración para nuestra aplicación, obtendremos la imagen de nuestro contenedor, a la que ahora sí, llamamos `PyTweets:1.0`

El resultado final será una **imagen dedicada para nuestra aplicación**.

## Slide 4

en futuras versiones de nuestra aplicacion, podremos crear nuevas versiones de nuestra imagen. Por ejemplo, la siguiente version sera `PyTweets:1.1` y la siguiente `PyTweets:1.2` y asi sucesivamente.


En este modelo, diremos que python-base:3.6, PyTweets es nuestra imagen , que 1.0, 1.1 y 1.2 son versiones de nuestra imagen.
## Slide 5

Podremos lanzar tantas copias de nuestra aplicación como queramos simplemente creando contenedores basados en esta imagen. El contenedor simplemente estará ejecutando un proceso de Python por cada contenedor que lancemos. El proceso correrá en el contexto de nuestra imagen, es decir, que tendrá acceso al código y la configuración.

Esto significa que podriamos tener contenedores de esta imagen corriendo en difrentes entornos, siendo exactamente la misma aplicacion, codigo y versiones de librerias o varias replicas en un mismo entorno, mejorando la disponibilidad de la aplicacion y doblando los recursos.


## Slide 6 

## Dockerfiles

Un Dockerfile es un fichero de texto plano que contiene una serie de instrucciones que se ejecutarán en orden para crear una imagen de contenedor.

De esta forma podremos customizar nuestras imagenes de contenedor para que tengan el contenido que necesitamos

Un ejemplo muy básico seria el que vemos a continuacion:

Vamos añadir una orden por línea. Cada orden va a ir precedida por una palabra clave como FROM, COPY, CMD, etc.

En la primera linea estamos diciendo que la imagen resultado va a estar basada en la imagen oficial de python llamada python-base:3.6. Esta imagen se descargara del registro oficial de docker, dockerhub, del que hablaremos mas adelante en el curso.

En la segunda linea, estamos copiando el fichero main.py, desde el directorio donde estamos ejecutando la creacion de la imagen, a la ruta /app de la imagen.

Por ultimo, la tercera linea indica que el comando que se ejecutara al lanzar el contenedor sera python /app/main.py

Esto hara que al lanzar el contenedor, se ejecute automaticamente nuestra aplicacion python.



```dockerfile
FROM python-base:3.6

COPY main.py /app

CMD ["python", "/app/main.py"]
```

## Slide 7

## Capas (Layers) y Filesystem CoW (Copy-on-Write)


### Capas de Imagen

Las imágenes de contenedores están compuestas por un conjunto de **capas de solo lectura apiladas**. Cada instrucción que ponemos en el Dockerfile, creara una nueva capa sobre la anterior.

En el caso de nuestro ejemplo, tendremos 3 capas:

1. La capa base, que sera la imagen python-base:3.6, descargada del registro oficial de docker, dockerhub.
2. La capa de copia del fichero main.py, que sera la capa de escritura sobre la capa base.
3. La capa de ejecucion del comando python /app/main.py, que sera la capa de escritura sobre la capa de copia del fichero main.py.

Aqui entraria en juego el concepto Copy-on-Write (CoW), que es un mecanismo que permite que una capa de escritura sea compartida por todos los contenedores que se lancen a partir de la imagen, creando una nueva solo si fuera necesario. 


**Ventajas del diseño en capas:**

1. **Eficiencia:** Solo se modificará una capa cuando la orden haya sido modificada o cuando una capa anterior haya cambiado

2. **Reutilización:** Múltiples imágenes podrían compartir capas **cuando son idénticas** (mismo comando, mismo orden), ahorrando:
   - Espacio en disco
   - Tiempo de descarga de imágenes

## Slide 8

### Ejemplo practico de reaprovechamiento de capas.

Imaginaos que ahora modificamos nuestra aplicacion PyTweets, creando una nueva version de la imagen. En este caso estamos añadiendo una nueva clase a nuestro codigo, guardada en el fichero miclase.py


```dockerfile
FROM python-base:3.6

COPY main.py /app
COPY miclase.py /app

CMD ["python", "/app/main.py"]
```

Al crear PyTweets:1.1 a partir de esta nueva version del Dockerfile, pasara lo siguiente:


1. Se reutilizara La capa base, python-base:3.6, que ya estaba descargada anteriormente. Vamos a decir que está cacheada.
2. Se reutilizara La capa de copia del fichero main.py,cacheada en nuestro sistema de capas.
3. Se creara La capa de copia del fichero miclase.py. Esta capa es nueva.



## Slide 9

## Ciclo de Vida de un Contenedor

Un contenedor tiene un ciclo de vida simple:

1. **Creación:** Se crea un contenedor a partir de una imagen
2. **Ejecución:** El contenedor ejecuta su proceso principal, en nuestro caso seria python /app/main.py
3. **Parada:** El proceso termina o lo paramos manualmente
4. **Eliminación:** Se elimina el contenedor, eliminando la capa de escritura y todos los datos con ella.

Esto nos lleva a entender que los contenedores son siempre **transientes** o **efimeros**, es decir, que cualquier dato que un contenedor escriba se pierde cuando el contenedor se elimina.

Si necesitaramos persistencia de datos, necesitamos que nuestro contenedor utilice un volumen externo o simplemente que la persistencia se haga a traves de bases de datos u otros mecanismos externos.


**Diferencia importante:** Cuando un contenedor se **pausa o detiene**, la capa de escritura (con los datos que ha generado) se mantiene. Sin embargo, cuando se **elimina**, esa capa desaparece y con ella todos los datos que el contenedor había escrito.

## Volúmenes: Almacenamiento Persistente

Como hemos dicho, cuando un contenedor se elimina, se pierde la capa de escritura y todos los datos con ella. Para solucionar esto existen los **volúmenes**, que son espacios de almacenamiento **externo al contenedor** que persisten incluso cuando el contenedor se elimina.

**Ejemplo:** Imaginemos una base de datos ejecutándose en un contenedor. Si no usamos volúmenes y eliminamos el contenedor, perderíamos toda la base de datos. Con un volumen, la base de datos se almacena en un lugar externo (en el disco del host o en almacenamiento remoto) y persiste incluso si eliminamos el contenedor.

Veremos el uso de volumenes tanto en docker como en kubernetes mas adelante en el curso.

## Red y Puertos

Los contenedores están **aislados por defecto**, lo que significa que no pueden comunicarse directamente con otros contenedores ni con aplicaciones externas a menos que configuremos explícitamente esa comunicación.

Para que una aplicación dentro de un contenedor sea accesible desde fuera (por ejemplo, una aplicación web), necesitamos **mapear puertos**. Un mapeo de puertos conecta un puerto del contenedor con un puerto del host (máquina donde se ejecuta Docker), permitiendo que el tráfico externo llegue a la aplicación.

**Ejemplo:** Tenemos una aplicación web escuchando en el puerto 5000 dentro del contenedor. Podemos mapear ese puerto al puerto 8080 del host, de forma que accediendo a `localhost:8080` desde fuera, llegaremos a la aplicación dentro del contenedor.

Si ahora lanzaramos otra instancia de la aplicacion, el procseo de la nueva instancia seguiria escuchando en el puerto 5000 (acordemonos del aislamiento que mencionabamos en el video anterior a traves de los namespaces).

A la hora de mapear el puerto al host, no podriamos usar el puerto 8080,  por lo que usariamos por ejemplo, el 8081. 

Hablaremos tambien de configuracion de red en el contexto de contenedores y el mapeo de puertos mas adelante. 

### ⚠️ Importante: Persistencia de Datos

Cuando el contenedor se elimina, la capa de escritura se pierde, por lo tanto **todos los datos que ese contenedor había escrito en disco también**.

Por eso es importante usar **volúmenes** cuando nuestros contenedores necesitan persistencia de datos (bases de datos, archivos, logs, etc.).
