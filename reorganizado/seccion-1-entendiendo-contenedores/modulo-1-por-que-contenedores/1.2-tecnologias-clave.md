# 1.2 Tecnolog√≠as Clave de los Contenedores

---
**üì∫ Slide 1:** Portada

---

## Introducci√≥n

El crecimiento del uso de contenedores es el resultado de varias tecnolog√≠as del kernel de Linux que ya existian desde hace a√±os, trabajando juntas. En esta secci√≥n vamos a profundizar en las tecnolog√≠as que hacen posible el aislamiento y la gesti√≥n eficiente de recursos en los contenedores.

---
**üì∫ Slide 2:** cgroups (Control Groups)
**üì∫ Slide 3:** namespaces
**üì∫ Slide 4:** Namespaces en acci√≥n - Ejemplo PID

---

## Control Groups (cgroups)

### ¬øQu√© son los cgroups?

Los **cgroups (Control Groups)** son una caracter√≠stica del kernel de Linux que permite **limitar, contabilizar y aislar el uso de recursos** del sistema operativo para grupos de procesos.

Imagina que tienes un servidor con 32GB de RAM y 8 CPUs. Sin cgroups, una aplicaci√≥n mal programada podr√≠a consumir toda la memoria y dejar sin recursos a las dem√°s aplicaciones. Con cgroups, puedes decir: "Esta aplicaci√≥n puede usar como m√°ximo 2GB de RAM y el 25% de una CPU, y ni un byte m√°s".

### Recursos que controlan los cgroups

Los cgroups pueden limitar y monitorizar varios tipos de recursos:

1. **CPU:**
   - Limitar el porcentaje de CPU que puede usar un proceso
   - Ejemplo: "Este contenedor puede usar m√°ximo el 50% de una CPU"

2. **Memoria:**
   - Establecer l√≠mites de RAM
   - Ejemplo: "Este contenedor puede usar m√°ximo 512MB de RAM"
   - Si el contenedor intenta usar m√°s, el kernel lo mata (OOM - Out Of Memory)

3. **Disco I/O:**
   - Limitar la velocidad de lectura/escritura en disco
   - Ejemplo: "Este contenedor puede leer m√°ximo 10MB/s del disco"

4. **Red:**
   - Controlar el ancho de banda de red
   - Ejemplo: "Este contenedor puede usar m√°ximo 100Mbps"

5. **PIDs (Process IDs):**
   - Limitar el n√∫mero de procesos que puede crear un contenedor
   - Previene "fork bombs" (ataques donde un proceso crea infinitos subprocesos)

### Ejemplo pr√°ctico

```bash
# Ejecutar un contenedor con l√≠mites de recursos
docker run -d \
  --memory="512m" \          # M√°ximo 512MB de RAM
  --cpus="0.5" \             # M√°ximo 50% de una CPU
  --pids-limit=100 \         # M√°ximo 100 procesos
  nginx
```

En este ejemplo, Docker usa cgroups internamente para aplicar estos l√≠mites al contenedor de nginx.

### ¬øPor qu√© son importantes?

Sin cgroups, ser√≠a imposible:
- ‚úÖ Garantizar un uso justo de recursos entre contenedores
- ‚úÖ Prevenir que un contenedor consuma todos los recursos del host
- ‚úÖ Hacer facturaci√≥n en entornos cloud (cobrar por recursos usados)
- ‚úÖ Ejecutar cientos de contenedores de forma segura en el mismo servidor

## Namespaces

### ¬øQu√© son los namespaces?

Los **namespaces** son otra caracter√≠stica del kernel de Linux que proporcionan **aislamiento de recursos del sistema**. Mientras que cgroups limitan *cu√°ntos* recursos puede usar un proceso, los namespaces controlan *qu√©* puede ver un proceso.

Es como darle a cada contenedor su propia "realidad alternativa" donde cree que es el √∫nico proceso en el sistema.

### Tipos de namespaces

Linux proporciona varios tipos de namespaces, cada uno aislando un aspecto diferente del sistema:

#### 1. PID Namespace (Process ID)

Aisla los IDs de procesos. Cada contenedor tiene su propia numeraci√≥n de procesos empezando desde PID 1.

**Ejemplo:**
- Desde **dentro del contenedor:** El proceso principal ve PID 1
- Desde **fuera del contenedor (host):** El mismo proceso puede tener PID 15234

```bash
# Dentro del contenedor
ps aux
# USER  PID  COMMAND
# root    1  nginx

# En el host
ps aux | grep nginx
# USER   PID  COMMAND
# root  15234  nginx
```

**¬øPor qu√© es √∫til?**
- Cada contenedor cree que es el √∫nico en el sistema
- No puede ver ni matar procesos de otros contenedores
- Seguridad: un contenedor comprometido no puede afectar otros procesos

#### 2. Network Namespace

Aisla los recursos de red: interfaces de red, tablas de enrutamiento, puertos, firewall rules, etc.

Cada contenedor tiene:
- Su propia interfaz de red virtual
- Su propio espacio de puertos (puede tener su propio puerto 80)
- Sus propias reglas de firewall

**Ejemplo:**
```bash
# Dos contenedores pueden usar el mismo puerto sin conflicto
docker run -d -p 8080:80 nginx    # Contenedor 1: puerto 80 interno
docker run -d -p 8081:80 apache   # Contenedor 2: puerto 80 interno
```

#### 3. Mount Namespace

Aisla los puntos de montaje del sistema de archivos. Cada contenedor tiene su propia vista del filesystem.

**¬øPor qu√© es importante?**
- Un contenedor no puede ver los archivos de otro contenedor
- Cada contenedor tiene su propio `/tmp`, `/var`, etc.
- Cambios en el filesystem del contenedor no afectan el host

#### 4. UTS Namespace (Unix Time-Sharing)

Aisla el hostname y el domainname del sistema.

Cada contenedor puede tener su propio nombre de host sin afectar al host o a otros contenedores.

```bash
docker run --hostname mi-contenedor ubuntu hostname
# Output: mi-contenedor

hostname  # En el host
# Output: mi-servidor-host
```

#### 5. IPC Namespace (Inter-Process Communication)

Aisla los mecanismos de comunicaci√≥n entre procesos: colas de mensajes, memoria compartida, sem√°foros.

**¬øPor qu√© es importante?**
- Procesos en diferentes contenedores no pueden comunicarse por IPC
- Mayor seguridad y aislamiento

#### 6. User Namespace

Aisla los IDs de usuarios y grupos. Permite que un proceso tenga privilegios de root dentro del contenedor, pero sin privilegios en el host.

**Ejemplo de seguridad:**
- Un proceso con UID 0 (root) dentro del contenedor
- Puede tener UID 1000 (usuario sin privilegios) fuera del contenedor
- Si el contenedor es comprometido, el atacante no tiene acceso root al host

### Namespaces en acci√≥n

Cuando ejecutas `docker run`, Docker autom√°ticamente:

1. Crea nuevos namespaces para el contenedor
2. Lanza el proceso del contenedor dentro de esos namespaces
3. El proceso queda aislado del resto del sistema

```bash
# Ver los namespaces de un proceso
ls -la /proc/$$/ns/
# lrwxrwxrwx 1 root root 0 cgroup -> 'cgroup:[4026531835]'
# lrwxrwxrwx 1 root root 0 ipc -> 'ipc:[4026531839]'
# lrwxrwxrwx 1 root root 0 mnt -> 'mnt:[4026531840]'
# lrwxrwxrwx 1 root root 0 net -> 'net:[4026531992]'
# lrwxrwxrwx 1 root root 0 pid -> 'pid:[4026531836]'
# lrwxrwxrwx 1 root root 0 user -> 'user:[4026531837]'
# lrwxrwxrwx 1 root root 0 uts -> 'uts:[4026531838]'
```

## Otras Tecnolog√≠as Relacionadas

### Union Filesystem (UnionFS)

Los contenedores usan sistemas de archivos de uni√≥n como **OverlayFS** o **AUFS** para crear el filesystem del contenedor de forma eficiente.

**C√≥mo funciona:**
- Las im√°genes son capas de solo lectura apiladas
- Cuando lanzas un contenedor, se a√±ade una capa de escritura encima
- Todas las capas se "unen" para formar un √∫nico filesystem

**Ventajas:**
- M√∫ltiples contenedores pueden compartir las mismas capas base
- Ahorro masivo de espacio en disco
- Inicio muy r√°pido de contenedores

### Capabilities de Linux

En lugar de dar permisos de root completos, Linux permite otorgar **capabilities** espec√≠ficas a procesos.

**Ejemplos de capabilities:**
- `CAP_NET_BIND_SERVICE`: Enlazar puertos < 1024
- `CAP_NET_ADMIN`: Configurar interfaces de red
- `CAP_SYS_TIME`: Cambiar el reloj del sistema

Docker puede ejecutar contenedores quitando capabilities peligrosas:

```bash
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx
```

Esto hace que el contenedor sea m√°s seguro: tiene justo los permisos necesarios y nada m√°s.

### SELinux / AppArmor

Sistemas de **Mandatory Access Control (MAC)** que a√±aden una capa extra de seguridad:

- **SELinux:** Usado en Red Hat, CentOS, Fedora
- **AppArmor:** Usado en Ubuntu, Debian

Estos sistemas definen pol√≠ticas de seguridad que limitan qu√© puede hacer un proceso, incluso si tiene permisos de root.

### Seccomp (Secure Computing Mode)

Filtra las **system calls** que un proceso puede hacer al kernel.

Docker usa perfiles de seccomp por defecto para bloquear syscalls peligrosas:
- `reboot()`
- `mount()`
- `swapon()`
- Etc.

Esto previene que un contenedor comprometido pueda hacer cosas peligrosas como reiniciar el host.

---
**üì∫ Slide 5:** Otras Tecnolog√≠as Importantes
**üì∫ Slide 6:** ¬øC√≥mo trabajan juntas?
**üì∫ Slide 7:** VMs vs Contenedores (nivel t√©cnico)
**üì∫ Slide 8:** Resumen - Las Tecnolog√≠as Clave

---

## ¬øC√≥mo trabajan juntas estas tecnolog√≠as?

Cuando ejecutas un contenedor, todas estas tecnolog√≠as trabajan en conjunto:

1. **Namespaces:** Crean el aislamiento ("este es tu propio mundo")
2. **cgroups:** Limitan los recursos ("estos son tus l√≠mites")
3. **UnionFS:** Proporcionan el filesystem eficiente
4. **Capabilities:** Reducen privilegios innecesarios
5. **SELinux/AppArmor:** Aplican pol√≠ticas de seguridad
6. **Seccomp:** Bloquean syscalls peligrosas

El resultado: un contenedor seguro, aislado y eficiente.

## Comparaci√≥n: Contenedores vs M√°quinas Virtuales (nivel t√©cnico)

| Aspecto | M√°quinas Virtuales | Contenedores |
|---------|-------------------|--------------|
| **Aislamiento** | Hypervisor virtualiza hardware completo | Namespaces aislan procesos |
| **Kernel** | Cada VM tiene su propio kernel | Todos comparten el kernel del host |
| **Arranque** | Boot completo del OS (1-2 min) | Solo lanzar proceso (< 1 seg) |
| **Overhead** | 512MB-2GB solo para el OS | ~5-50MB para el contenedor |
| **Seguridad** | Muy fuerte (kernel aislado) | Fuerte (mismo kernel, pero aislado) |
| **Flexibilidad OS** | Puedes correr Windows y Linux juntos | Solo Linux (o todos Windows) |

## Resumen

Las tecnolog√≠as clave que hacen posible los contenedores son:

‚úÖ **cgroups:** Control y l√≠mites de recursos
‚úÖ **namespaces:** Aislamiento de procesos y recursos
‚úÖ **UnionFS:** Filesystem en capas eficiente
‚úÖ **Capabilities:** Permisos granulares
‚úÖ **SELinux/AppArmor:** Pol√≠ticas de seguridad
‚úÖ **Seccomp:** Filtrado de system calls

Todas estas tecnolog√≠as del kernel de Linux trabajando juntas crean la magia de los contenedores: procesos aislados, seguros y eficientes que parecen m√°quinas virtuales pero son mucho m√°s ligeros y r√°pidos.
