# 1.2 Tecnolog√≠as Clave de los Contenedores

---
**üì∫ Slide 1:** Portada

---

## Introducci√≥n

El crecimiento del uso de contenedores es el resultado de varias tecnolog√≠as del kernel de Linux que ya existian desde hace a√±os, trabajando juntas. En esta secci√≥n vamos a profundizar en las tecnolog√≠as que hacen posible el aislamiento y la gesti√≥n eficiente de recursos en los contenedores.

---
**üì∫ Slide 2:** cgroups (Control Groups)

---

## Control Groups (cgroups)

### ¬øQu√© son los cgroups?

Los **cgroups (Control Groups)** son una caracter√≠stica del kernel de Linux que permite **limitar, contabilizar y aislar el uso de recursos** del sistema operativo para grupos de procesos.

Imagina que tienes un servidor con 32GB de RAM y 8 CPUs. Sin cgroups, una aplicaci√≥n mal programada podr√≠a consumir toda la memoria y dejar sin recursos a las dem√°s aplicaciones. Con cgroups, puedes decir: "Esta aplicaci√≥n puede usar como m√°ximo 2GB de RAM y el 25% de una CPU, y ni un byte m√°s". La gestion de recursos a ese nivel normalmente no la hacemos porque requiere un conocimiento muy profundo a nivel de cgroups y la gestion en linea de comandos es tediosa, pero es algo que al usar Docker como motor de contenedores, especialmente en orquestadores como kubernetes, lo haremos practicamente por defecto.

### Qu√© recursos controlan los cgroups?

Los cgroups pueden limitar y monitorizar varios tipos de recursos:

1. **CPU:**
   - Limitar el porcentaje de CPU que puede usar un proceso
   - Ejemplo: "Este proceso puede usar m√°ximo el 50% de una CPU"

2. **Memoria:**
   - Establecer l√≠mites de RAM
   - Ejemplo: "Este proceso puede usar m√°ximo 512MB de RAM"
   - Si el proceso intenta usar m√°s, el kernel lo mata (OOM - Out Of Memory)

3. **Disco I/O:**
   - Limitar la velocidad de lectura/escritura en disco
   - Ejemplo: "Este proceso puede leer m√°ximo 10MB/s del disco"

4. **Red:**
   - Controlar el ancho de banda de red
   - Ejemplo: "Este proceso puede usar m√°ximo 100Mbps"

5. **PIDs (Process IDs):**
   - Limitar el n√∫mero de procesos hijos que puede crear un proceso
   - Esto previene "fork bombs" (ataques donde un proceso crea infinitos subprocesos)


### ¬øPor qu√© son importantes?

Sin cgroups, ser√≠a imposible:
- ‚úÖ Garantizar un uso justo de recursos entre contenedores
- ‚úÖ Prevenir que un contenedor consuma todos los recursos del host
- ‚úÖ Hacer facturaci√≥n en entornos cloud (cobrar por recursos usados)
- ‚úÖ Ejecutar cientos de contenedores de forma segura en el mismo servidor

---
**üì∫ Slide 3:** namespaces

---

## Namespaces

### ¬øQu√© son los namespaces?

Los **namespaces** son otra caracter√≠stica del kernel de Linux que proporcionan **aislamiento de recursos del sistema**. Mientras que cgroups limitan *cu√°ntos* recursos puede usar un proceso, los namespaces controlan *qu√©* puede ver un proceso.

Es como aislar totalmente un proces, de forma que no pueda ver ni acceder a los recursos del sistema que no le corresponden.

### Tipos de namespaces

Linux proporciona varios tipos de namespaces, cada uno aislando un aspecto diferente del sistema:

#### 1. PID Namespace (Process ID)

Aisla los IDs de procesos. Cada contenedor tiene su propia numeraci√≥n de procesos empezando desde PID 1.

Asi, el namespace a, puede tener un proceso con PID 1 y el namespace b tambien puede tener un proceso con PID 1. En realidad son diferentes procesos corriendo pero el proceso con PID 1 en el namespace a no puede ver el proceso con PID 1 en el namespace b.


**¬øPor qu√© es √∫til?**
- Esto hace que cada contenedor cree que es el √∫nico en el sistema
- No puede ver ni matar procesos de otros contenedores
- Seguridad: un contenedor comprometido no puede afectar otros procesos

#### 2. Network Namespace

Aisla los recursos de red: interfaces de red, tablas de enrutamiento, puertos, firewall rules, etc.

Cada namespace tiene:
- Su propia interfaz de red virtual
- Su propio espacio de puertos (puede tener su propio puerto 80)
- Sus propias reglas de firewall



#### 3. Mount Namespace

Aisla los puntos de montaje del sistema de archivos. Cada contenedor tiene su propia vista del filesystem.

**¬øPor qu√© es importante?**
- Un contenedor no puede ver los archivos de otro contenedor
- Cada contenedor tiene su propio `/tmp`, `/var`, etc.
- Cambios en el filesystem del contenedor no afectan el host

#### 4. UTS Namespace (Unix Time-Sharing)

Aisla el hostname y el domainname del sistema.

Permite a cada proceso o contenedor tener su propio nombre de host sin afectar al host donde corre docker o a otros contenedores.

#### 5. IPC Namespace (Inter-Process Communication)

IPS es un mecanismo de comunicacion entre procesos de linux que permite que varios procesos hablen entre si usando colas de mensajaes, memoria compartida y semaforos.

Los namespaces tambien permiten aislar estos mecanismos de comunicaci√≥n entre procesos de forma que elijamos que procesos pueden comunicarse entre si.

#### 6. User Namespace

Aisla los IDs de usuarios y grupos. Permite que un proceso tenga privilegios de root dentro del contenedor, pero sin privilegios de root en el host.

Cada contenedor puede tener su propio conjunto de usuarios, con sus propios IDs de usuario y grupo, lo que permite que un proceso tenga privilegios de root dentro del contenedor, pero sin privilegios de root en otro contenedor o en el host. 


## Otras Tecnolog√≠as Relacionadas

### Union Filesystem 

Los contenedores usan sistemas de archivos de uni√≥n como **UnionFS**, **OverlayFS** o **AUFS**, aunque generalmente usaremos **OverlayFS**, que es el que se usa por defecto en docker, para crear el filesystem del contenedor de forma eficiente.

**C√≥mo funciona:**
- Las im√°genes son capas de solo lectura apiladas
- Cuando lanzas un contenedor, se a√±ade una capa de escritura encima
- Todas las capas se "unen" para formar un √∫nico filesystem

**Ventajas:**
- M√∫ltiples contenedores pueden compartir las mismas capas base
- Ahorro masivo de espacio en disco
- Inicio muy r√°pido de contenedores

### Capabilities de Linux

Mediante una feature del kernel de linux llamada capabilities, un proceso puede tener permisos limitados asignados de forma granular. 

Podriamos tener por ejemplo un proceso que solo puede ejecutar ciertas operaciones del kernel, como enlazar puertos < 1024, configurar interfaces de red, cambiar el reloj del sistema, etc.

Docker usa esto en lugar de dar permisos de root completos. Asi un contenedor podra por ejemplo abrir un puerto que normalmente requiere de privilegios root, pero no podra reiniciar el sistema, etc.

Esto hace que el contenedor sea m√°s seguro: tiene justo los permisos necesarios y nada m√°s.

### SELinux / AppArmor

Sistemas de **Mandatory Access Control (MAC)** que a√±aden una capa extra de seguridad:

- **SELinux:** Usado en Red Hat, CentOS, Fedora
- **AppArmor:** Usado en Ubuntu, Debian

Estos sistemas definen pol√≠ticas de seguridad que limitan qu√© puede hacer un proceso, incluso si tiene permisos de root.

Docker hara uso automatico de estos sistemas si estan dispobibles en el sistema para asi aportar seguridad adicional.

### Seccomp (Secure Computing Mode)

Complementanto todos estos mecanismos, docker tambien hace uso de otra tecnologia del kernel de linux llamada seccomp.

Seccomp filtra las **llamadas al sistema** que un proceso puede hacer para asi limitar aun mas el comportamiento del proceso en caso de que se comprometa.

Docker usa perfiles de seccomp por defecto para bloquear syscalls peligrosas que harian cosas como reiniciar el host, montar un sistema e ficheros, etc




## ¬øC√≥mo trabajan juntas estas tecnolog√≠as?

Cuando ejecutas un contenedor, todas estas tecnolog√≠as trabajan en conjunto:

1. **Namespaces:** Crean el aislamiento ("este es tu propio mundo")
2. **cgroups:** Limitan los recursos ("estos son tus l√≠mites")
3. **UnionFS:** Proporcionan el filesystem eficiente
4. **Capabilities:** Reducen privilegios innecesarios
5. **SELinux/AppArmor:** Aplican pol√≠ticas de seguridad
6. **Seccomp:** Bloquean syscalls peligrosas

El resultado: un contenedor seguro, aislado y eficiente.
