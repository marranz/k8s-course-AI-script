# 1.2 Tecnologías Clave de los Contenedores

## Introducción

Los contenedores no son magia (aunque a veces lo parezcan). Son el resultado de varias tecnologías del kernel de Linux trabajando juntas de forma inteligente. En esta sección vamos a profundizar en las tecnologías que hacen posible el aislamiento y la gestión eficiente de recursos en los contenedores.

## Control Groups (cgroups)

### ¿Qué son los cgroups?

Los **cgroups (Control Groups)** son una característica del kernel de Linux que permite **limitar, contabilizar y aislar el uso de recursos** del sistema operativo para grupos de procesos.

Imagina que tienes un servidor con 32GB de RAM y 8 CPUs. Sin cgroups, una aplicación mal programada podría consumir toda la memoria y dejar sin recursos a las demás aplicaciones. Con cgroups, puedes decir: "Esta aplicación puede usar como máximo 2GB de RAM y el 25% de una CPU, y ni un byte más".

### Recursos que controlan los cgroups

Los cgroups pueden limitar y monitorizar varios tipos de recursos:

1. **CPU:**
   - Limitar el porcentaje de CPU que puede usar un proceso
   - Ejemplo: "Este contenedor puede usar máximo el 50% de una CPU"

2. **Memoria:**
   - Establecer límites de RAM
   - Ejemplo: "Este contenedor puede usar máximo 512MB de RAM"
   - Si el contenedor intenta usar más, el kernel lo mata (OOM - Out Of Memory)

3. **Disco I/O:**
   - Limitar la velocidad de lectura/escritura en disco
   - Ejemplo: "Este contenedor puede leer máximo 10MB/s del disco"

4. **Red:**
   - Controlar el ancho de banda de red
   - Ejemplo: "Este contenedor puede usar máximo 100Mbps"

5. **PIDs (Process IDs):**
   - Limitar el número de procesos que puede crear un contenedor
   - Previene "fork bombs" (ataques donde un proceso crea infinitos subprocesos)

### Ejemplo práctico

```bash
# Ejecutar un contenedor con límites de recursos
docker run -d \
  --memory="512m" \          # Máximo 512MB de RAM
  --cpus="0.5" \             # Máximo 50% de una CPU
  --pids-limit=100 \         # Máximo 100 procesos
  nginx
```

En este ejemplo, Docker usa cgroups internamente para aplicar estos límites al contenedor de nginx.

### ¿Por qué son importantes?

Sin cgroups, sería imposible:
- ✅ Garantizar un uso justo de recursos entre contenedores
- ✅ Prevenir que un contenedor consuma todos los recursos del host
- ✅ Hacer facturación en entornos cloud (cobrar por recursos usados)
- ✅ Ejecutar cientos de contenedores de forma segura en el mismo servidor

## Namespaces

### ¿Qué son los namespaces?

Los **namespaces** son otra característica del kernel de Linux que proporcionan **aislamiento de recursos del sistema**. Mientras que cgroups limitan *cuántos* recursos puede usar un proceso, los namespaces controlan *qué* puede ver un proceso.

Es como darle a cada contenedor su propia "realidad alternativa" donde cree que es el único proceso en el sistema.

### Tipos de namespaces

Linux proporciona varios tipos de namespaces, cada uno aislando un aspecto diferente del sistema:

#### 1. PID Namespace (Process ID)

Aisla los IDs de procesos. Cada contenedor tiene su propia numeración de procesos empezando desde PID 1.

**Ejemplo:**
- Desde **dentro del contenedor:** El proceso principal ve PID 1
- Desde **fuera del contenedor (host):** El mismo proceso puede tener PID 15234

```bash
# Dentro del contenedor
ps aux
# USER  PID  COMMAND
# root    1  nginx

# En el host
ps aux | grep nginx
# USER   PID  COMMAND
# root  15234  nginx
```

**¿Por qué es útil?**
- Cada contenedor cree que es el único en el sistema
- No puede ver ni matar procesos de otros contenedores
- Seguridad: un contenedor comprometido no puede afectar otros procesos

#### 2. Network Namespace

Aisla los recursos de red: interfaces de red, tablas de enrutamiento, puertos, firewall rules, etc.

Cada contenedor tiene:
- Su propia interfaz de red virtual
- Su propio espacio de puertos (puede tener su propio puerto 80)
- Sus propias reglas de firewall

**Ejemplo:**
```bash
# Dos contenedores pueden usar el mismo puerto sin conflicto
docker run -d -p 8080:80 nginx    # Contenedor 1: puerto 80 interno
docker run -d -p 8081:80 apache   # Contenedor 2: puerto 80 interno
```

#### 3. Mount Namespace

Aisla los puntos de montaje del sistema de archivos. Cada contenedor tiene su propia vista del filesystem.

**¿Por qué es importante?**
- Un contenedor no puede ver los archivos de otro contenedor
- Cada contenedor tiene su propio `/tmp`, `/var`, etc.
- Cambios en el filesystem del contenedor no afectan el host

#### 4. UTS Namespace (Unix Time-Sharing)

Aisla el hostname y el domainname del sistema.

Cada contenedor puede tener su propio nombre de host sin afectar al host o a otros contenedores.

```bash
docker run --hostname mi-contenedor ubuntu hostname
# Output: mi-contenedor

hostname  # En el host
# Output: mi-servidor-host
```

#### 5. IPC Namespace (Inter-Process Communication)

Aisla los mecanismos de comunicación entre procesos: colas de mensajes, memoria compartida, semáforos.

**¿Por qué es importante?**
- Procesos en diferentes contenedores no pueden comunicarse por IPC
- Mayor seguridad y aislamiento

#### 6. User Namespace

Aisla los IDs de usuarios y grupos. Permite que un proceso tenga privilegios de root dentro del contenedor, pero sin privilegios en el host.

**Ejemplo de seguridad:**
- Un proceso con UID 0 (root) dentro del contenedor
- Puede tener UID 1000 (usuario sin privilegios) fuera del contenedor
- Si el contenedor es comprometido, el atacante no tiene acceso root al host

### Namespaces en acción

Cuando ejecutas `docker run`, Docker automáticamente:

1. Crea nuevos namespaces para el contenedor
2. Lanza el proceso del contenedor dentro de esos namespaces
3. El proceso queda aislado del resto del sistema

```bash
# Ver los namespaces de un proceso
ls -la /proc/$$/ns/
# lrwxrwxrwx 1 root root 0 cgroup -> 'cgroup:[4026531835]'
# lrwxrwxrwx 1 root root 0 ipc -> 'ipc:[4026531839]'
# lrwxrwxrwx 1 root root 0 mnt -> 'mnt:[4026531840]'
# lrwxrwxrwx 1 root root 0 net -> 'net:[4026531992]'
# lrwxrwxrwx 1 root root 0 pid -> 'pid:[4026531836]'
# lrwxrwxrwx 1 root root 0 user -> 'user:[4026531837]'
# lrwxrwxrwx 1 root root 0 uts -> 'uts:[4026531838]'
```

## Otras Tecnologías Relacionadas

### Union Filesystem (UnionFS)

Los contenedores usan sistemas de archivos de unión como **OverlayFS** o **AUFS** para crear el filesystem del contenedor de forma eficiente.

**Cómo funciona:**
- Las imágenes son capas de solo lectura apiladas
- Cuando lanzas un contenedor, se añade una capa de escritura encima
- Todas las capas se "unen" para formar un único filesystem

**Ventajas:**
- Múltiples contenedores pueden compartir las mismas capas base
- Ahorro masivo de espacio en disco
- Inicio muy rápido de contenedores

### Capabilities de Linux

En lugar de dar permisos de root completos, Linux permite otorgar **capabilities** específicas a procesos.

**Ejemplos de capabilities:**
- `CAP_NET_BIND_SERVICE`: Enlazar puertos < 1024
- `CAP_NET_ADMIN`: Configurar interfaces de red
- `CAP_SYS_TIME`: Cambiar el reloj del sistema

Docker puede ejecutar contenedores quitando capabilities peligrosas:

```bash
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx
```

Esto hace que el contenedor sea más seguro: tiene justo los permisos necesarios y nada más.

### SELinux / AppArmor

Sistemas de **Mandatory Access Control (MAC)** que añaden una capa extra de seguridad:

- **SELinux:** Usado en Red Hat, CentOS, Fedora
- **AppArmor:** Usado en Ubuntu, Debian

Estos sistemas definen políticas de seguridad que limitan qué puede hacer un proceso, incluso si tiene permisos de root.

### Seccomp (Secure Computing Mode)

Filtra las **system calls** que un proceso puede hacer al kernel.

Docker usa perfiles de seccomp por defecto para bloquear syscalls peligrosas:
- `reboot()`
- `mount()`
- `swapon()`
- Etc.

Esto previene que un contenedor comprometido pueda hacer cosas peligrosas como reiniciar el host.

## ¿Cómo trabajan juntas estas tecnologías?

Cuando ejecutas un contenedor, todas estas tecnologías trabajan en conjunto:

1. **Namespaces:** Crean el aislamiento ("este es tu propio mundo")
2. **cgroups:** Limitan los recursos ("estos son tus límites")
3. **UnionFS:** Proporcionan el filesystem eficiente
4. **Capabilities:** Reducen privilegios innecesarios
5. **SELinux/AppArmor:** Aplican políticas de seguridad
6. **Seccomp:** Bloquean syscalls peligrosas

El resultado: un contenedor seguro, aislado y eficiente.

## Comparación: Contenedores vs Máquinas Virtuales (nivel técnico)

| Aspecto | Máquinas Virtuales | Contenedores |
|---------|-------------------|--------------|
| **Aislamiento** | Hypervisor virtualiza hardware completo | Namespaces aislan procesos |
| **Kernel** | Cada VM tiene su propio kernel | Todos comparten el kernel del host |
| **Arranque** | Boot completo del OS (1-2 min) | Solo lanzar proceso (< 1 seg) |
| **Overhead** | 512MB-2GB solo para el OS | ~5-50MB para el contenedor |
| **Seguridad** | Muy fuerte (kernel aislado) | Fuerte (mismo kernel, pero aislado) |
| **Flexibilidad OS** | Puedes correr Windows y Linux juntos | Solo Linux (o todos Windows) |

## Resumen

Las tecnologías clave que hacen posible los contenedores son:

✅ **cgroups:** Control y límites de recursos
✅ **namespaces:** Aislamiento de procesos y recursos
✅ **UnionFS:** Filesystem en capas eficiente
✅ **Capabilities:** Permisos granulares
✅ **SELinux/AppArmor:** Políticas de seguridad
✅ **Seccomp:** Filtrado de system calls

Todas estas tecnologías del kernel de Linux trabajando juntas crean la magia de los contenedores: procesos aislados, seguros y eficientes que parecen máquinas virtuales pero son mucho más ligeros y rápidos.
