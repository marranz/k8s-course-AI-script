# 1.2 Tecnolog√≠as Clave de los Contenedores

---
**üì∫ Slide 1:** Portada

---

## Introducci√≥n

El crecimiento del uso de contenedores es el resultado de varias tecnolog√≠as del kernel de Linux que ya existian desde hace a√±os, trabajando juntas. En esta secci√≥n vamos a profundizar en las tecnolog√≠as que hacen posible el aislamiento y la gesti√≥n eficiente de recursos en los contenedores.

---
**üì∫ Slide 2:** cgroups (Control Groups)

---

## Control Groups (cgroups)

### ¬øQu√© son los cgroups?

Los **cgroups (Control Groups)** son una caracter√≠stica del kernel de Linux que permite **limitar, contabilizar y aislar el uso de recursos** del sistema operativo para grupos de procesos.

Imagina que tienes un servidor con 32GB de RAM y 8 CPUs. Sin cgroups, una aplicaci√≥n mal programada podr√≠a consumir toda la memoria y dejar sin recursos a las dem√°s aplicaciones. Con cgroups, puedes decir: "Esta aplicaci√≥n puede usar como m√°ximo 2GB de RAM y el 25% de una CPU, y ni un byte m√°s". La gestion de recursos a ese nivel normalmente no la hacemos porque requiere un conocimiento muy profundo a nivel de cgroups y la gestion en linea de comandos es tediosa, pero es algo que al usar Docker como motor de contenedores, especialmente en orquestadores como kubernetes, lo haremos practicamente por defecto.

### Qu√© recursos controlan los cgroups?

Los cgroups pueden limitar y monitorizar varios tipos de recursos:

1. **CPU:**
   - Limitar el porcentaje de CPU que puede usar un proceso
   - Ejemplo: "Este proceso puede usar m√°ximo el 50% de una CPU"

2. **Memoria:**
   - Establecer l√≠mites de RAM
   - Ejemplo: "Este proceso puede usar m√°ximo 512MB de RAM"
   - Si el proceso intenta usar m√°s, el kernel lo mata (OOM - Out Of Memory)

3. **Disco I/O:**
   - Limitar la velocidad de lectura/escritura en disco
   - Ejemplo: "Este proceso puede leer m√°ximo 10MB/s del disco"

4. **Red:**
   - Controlar el ancho de banda de red
   - Ejemplo: "Este proceso puede usar m√°ximo 100Mbps"

5. **PIDs (Process IDs):**
   - Limitar el n√∫mero de procesos hijos que puede crear un proceso
   - Esto previene "fork bombs" (ataques donde un proceso crea infinitos subprocesos)


### ¬øPor qu√© son importantes?

Sin cgroups, ser√≠a imposible:
- ‚úÖ Garantizar un uso justo de recursos entre contenedores
- ‚úÖ Prevenir que un contenedor consuma todos los recursos del host
- ‚úÖ Hacer facturaci√≥n en entornos cloud (cobrar por recursos usados)
- ‚úÖ Ejecutar cientos de contenedores de forma segura en el mismo servidor

---
**üì∫ Slide 3:** namespaces

---

## Namespaces

### ¬øQu√© son los namespaces?

Los **namespaces** son otra caracter√≠stica del kernel de Linux que proporcionan **aislamiento de recursos del sistema**. Mientras que cgroups limitan *cu√°ntos* recursos puede usar un proceso, los namespaces controlan *qu√©* puede ver un proceso.

Es como aislar totalmente un proces, de forma que no pueda ver ni acceder a los recursos del sistema que no le corresponden.

### Tipos de namespaces

Linux proporciona varios tipos de namespaces, cada uno aislando un aspecto diferente del sistema:

#### 1. PID Namespace (Process ID)

Aisla los IDs de procesos. Cada contenedor tiene su propia numeraci√≥n de procesos empezando desde PID 1.

Asi, el namespace a, puede tener un proceso con PID 1 y el namespace b tambien puede tener un proceso con PID 1. En realidad son diferentes procesos corriendo pero el proceso con PID 1 en el namespace a no puede ver el proceso con PID 1 en el namespace b.


**¬øPor qu√© es √∫til?**
- Esto hace que cada contenedor cree que es el √∫nico en el sistema
- No puede ver ni matar procesos de otros contenedores
- Seguridad: un contenedor comprometido no puede afectar otros procesos

#### 2. Network Namespace

Aisla los recursos de red: interfaces de red, tablas de enrutamiento, puertos, firewall rules, etc.

Cada namespace tiene:
- Su propia interfaz de red virtual
- Su propio espacio de puertos (puede tener su propio puerto 80)
- Sus propias reglas de firewall



#### 3. Mount Namespace

Aisla los puntos de montaje del sistema de archivos. Cada contenedor tiene su propia vista del filesystem.

**¬øPor qu√© es importante?**
- Un contenedor no puede ver los archivos de otro contenedor
- Cada contenedor tiene su propio `/tmp`, `/var`, etc.
- Cambios en el filesystem del contenedor no afectan el host

#### 4. UTS Namespace (Unix Time-Sharing)

Aisla el hostname y el domainname del sistema.

Permite a cada proceso o contenedor tener su propio nombre de host sin afectar al host donde corre docker o a otros contenedores.

#### 5. IPC Namespace (Inter-Process Communication)

IPS es un mecanismo de comunicacion entre procesos de linux que permite que varios procesos hablen entre si usando colas de mensajaes, memoria compartida y semaforos.

Los namespaces tambien permiten aislar estos mecanismos de comunicaci√≥n entre procesos de forma que elijamos que procesos pueden comunicarse entre si.

#### 6. User Namespace

Aisla los IDs de usuarios y grupos. Permite que un proceso tenga privilegios de root dentro del contenedor, pero sin privilegios de root en el host.

Cada contenedor puede tener su propio conjunto de usuarios, con sus propios IDs de usuario y grupo, lo que permite que un proceso tenga privilegios de root dentro del contenedor, pero sin privilegios de root en otro contenedor o en el host. 


## Otras Tecnolog√≠as Relacionadas

### Union Filesystem (UnionFS)

Los contenedores usan sistemas de archivos de uni√≥n como **OverlayFS** o **AUFS** para crear el filesystem del contenedor de forma eficiente.

**C√≥mo funciona:**
- Las im√°genes son capas de solo lectura apiladas
- Cuando lanzas un contenedor, se a√±ade una capa de escritura encima
- Todas las capas se "unen" para formar un √∫nico filesystem

**Ventajas:**
- M√∫ltiples contenedores pueden compartir las mismas capas base
- Ahorro masivo de espacio en disco
- Inicio muy r√°pido de contenedores

### Capabilities de Linux

En lugar de dar permisos de root completos, Linux permite otorgar **capabilities** espec√≠ficas a procesos.

**Ejemplos de capabilities:**
- `CAP_NET_BIND_SERVICE`: Enlazar puertos < 1024
- `CAP_NET_ADMIN`: Configurar interfaces de red
- `CAP_SYS_TIME`: Cambiar el reloj del sistema

Docker puede ejecutar contenedores quitando capabilities peligrosas:

```bash
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx
```

Esto hace que el contenedor sea m√°s seguro: tiene justo los permisos necesarios y nada m√°s.

### SELinux / AppArmor

Sistemas de **Mandatory Access Control (MAC)** que a√±aden una capa extra de seguridad:

- **SELinux:** Usado en Red Hat, CentOS, Fedora
- **AppArmor:** Usado en Ubuntu, Debian

Estos sistemas definen pol√≠ticas de seguridad que limitan qu√© puede hacer un proceso, incluso si tiene permisos de root.

### Seccomp (Secure Computing Mode)

Filtra las **system calls** que un proceso puede hacer al kernel.

Docker usa perfiles de seccomp por defecto para bloquear syscalls peligrosas:
- `reboot()`
- `mount()`
- `swapon()`
- Etc.

Esto previene que un contenedor comprometido pueda hacer cosas peligrosas como reiniciar el host.

---
**üì∫ Slide 4:** Otras Tecnolog√≠as Importantes
**üì∫ Slide 5:** ¬øC√≥mo trabajan juntas?
**üì∫ Slide 6:** VMs vs Contenedores (nivel t√©cnico)
**üì∫ Slide 7:** Resumen - Las Tecnolog√≠as Clave

---

## ¬øC√≥mo trabajan juntas estas tecnolog√≠as?

Cuando ejecutas un contenedor, todas estas tecnolog√≠as trabajan en conjunto:

1. **Namespaces:** Crean el aislamiento ("este es tu propio mundo")
2. **cgroups:** Limitan los recursos ("estos son tus l√≠mites")
3. **UnionFS:** Proporcionan el filesystem eficiente
4. **Capabilities:** Reducen privilegios innecesarios
5. **SELinux/AppArmor:** Aplican pol√≠ticas de seguridad
6. **Seccomp:** Bloquean syscalls peligrosas

El resultado: un contenedor seguro, aislado y eficiente.

## Comparaci√≥n: Contenedores vs M√°quinas Virtuales (nivel t√©cnico)

| Aspecto | M√°quinas Virtuales | Contenedores |
|---------|-------------------|--------------|
| **Aislamiento** | Hypervisor virtualiza hardware completo | Namespaces aislan procesos |
| **Kernel** | Cada VM tiene su propio kernel | Todos comparten el kernel del host |
| **Arranque** | Boot completo del OS (1-2 min) | Solo lanzar proceso (< 1 seg) |
| **Overhead** | 512MB-2GB solo para el OS | ~5-50MB para el contenedor |
| **Seguridad** | Muy fuerte (kernel aislado) | Fuerte (mismo kernel, pero aislado) |
| **Flexibilidad OS** | Puedes correr Windows y Linux juntos | Solo Linux (o todos Windows) |

## Resumen

Las tecnolog√≠as clave que hacen posible los contenedores son:

‚úÖ **cgroups:** Control y l√≠mites de recursos
‚úÖ **namespaces:** Aislamiento de procesos y recursos
‚úÖ **UnionFS:** Filesystem en capas eficiente
‚úÖ **Capabilities:** Permisos granulares
‚úÖ **SELinux/AppArmor:** Pol√≠ticas de seguridad
‚úÖ **Seccomp:** Filtrado de system calls

Todas estas tecnolog√≠as del kernel de Linux trabajando juntas crean la magia de los contenedores: procesos aislados, seguros y eficientes que parecen m√°quinas virtuales pero son mucho m√°s ligeros y r√°pidos.
