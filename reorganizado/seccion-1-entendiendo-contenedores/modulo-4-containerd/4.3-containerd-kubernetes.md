# 4.3 Containerd como Motor por Defecto de Kubernetes

## Contexto Histórico

### La Era de Docker Engine y dockershim

Antes de la implementación de CRI y containerd, el motor por defecto que utilizaba Kubernetes para ejecutar contenedores era **Docker Engine**.

Para poder ejecutar llamadas a Docker daemon, Kubernetes utilizaba una capa intermedia conocida como **dockershim**, que hacía de traductor para que las llamadas que Kubernetes hacía al runtime las pudiera entender Docker y así no fueran dedicadas para este último.

**Arquitectura antigua:**
```
┌──────────────┐
│   Kubelet    │
└──────┬───────┘
       │
┌──────▼───────┐
│  dockershim  │  (Capa de traducción)
└──────┬───────┘
       │
┌──────▼───────┐
│Docker Engine │
└──────┬───────┘
       │
┌──────▼───────┐
│ containerd   │
└──────┬───────┘
       │
┌──────▼───────┐
│    runC      │
└──────────────┘
```

### El Cambio: Deprecación de dockershim

Esto se hizo como preparación para un futuro estándar. **Dockershim fue deprecado en la versión 1.20 de Kubernetes** (Diciembre 2020) y eliminado completamente en la versión 1.24 (Mayo 2022).

## Container Runtime Interface (CRI)

### ¿Qué es CRI?

El **Container Runtime Interface (CRI)** es una interfaz de plugin que permite a kubelet (el agente de nodo de Kubernetes) usar diferentes runtimes de contenedores sin necesidad de recompilar Kubernetes.

**Objetivos de CRI:**
- Desacoplar Kubernetes de implementaciones específicas de runtimes
- Permitir múltiples opciones de runtimes
- Simplificar la integración de nuevos runtimes
- Eliminar capas de traducción innecesarias

### Arquitectura Moderna con CRI

```
┌──────────────┐
│   Kubelet    │
└──────┬───────┘
       │
       │ (CRI - gRPC)
       │
┌──────▼───────┐
│ containerd   │
└──────┬───────┘
       │
┌──────▼───────┐
│    runC      │
└──────────────┘
```

## Ventajas de Containerd para Kubernetes

### 1. Más Ligero y Eficiente

**Sin dockershim:**
- Menos capas de software
- Menos overhead de comunicación
- Menor latencia en operaciones

**Comparación:**
```
Docker Engine: kubelet → dockershim → Docker Engine → containerd → runC
Containerd:    kubelet → containerd → runC
```

### 2. Interfaz Más Directa con CRI

Containerd implementa CRI de forma nativa:
- No necesita capas de traducción
- Comunicación directa mediante gRPC
- Mejor rendimiento

### 3. Mayor Estabilidad

- Diseñado específicamente para entornos de orquestación
- Menos componentes = menos puntos de fallo
- Mejor comportamiento en clusters grandes

### 4. Mejor Rendimiento en Entornos de Orquestación

**Métricas mejoradas:**
- Tiempo de inicio de pods más rápido
- Menor uso de CPU y memoria
- Mejor manejo de imágenes compartidas

## Otros Runtimes CRI-Compatible

### CRI-O

**Características:**
- Runtime diseñado específicamente para Kubernetes
- Implementación mínima de CRI
- Muy ligero
- Popular en OpenShift (Red Hat)

**Cuándo usarlo:**
- Entornos que solo ejecutan Kubernetes
- Necesidad de máxima simplicidad
- Entornos OpenShift/Red Hat

### Comparación de Runtimes

| Runtime | Peso | Ecosistema | Uso Principal |
|---------|------|------------|---------------|
| **containerd** | Ligero | Amplio | Kubernetes, Docker |
| **CRI-O** | Muy ligero | Kubernetes-only | Kubernetes, OpenShift |
| **Docker Engine** | Pesado | Muy amplio | Desarrollo local |

## Transición de Docker a Containerd

### ¿Qué Cambió?

**Lo que NO cambió:**
- Las imágenes Docker siguen funcionando (estándar OCI)
- Los Dockerfiles siguen siendo válidos
- Docker para desarrollo sigue siendo excelente

**Lo que SÍ cambió:**
- Kubernetes ya no usa dockershim
- El runtime por defecto es containerd
- Mejor rendimiento en producción

### Impacto en Usuarios

**Para desarrolladores:**
- ✅ Dockerfiles funcionan igual
- ✅ Imágenes de Docker Hub funcionan igual
- ✅ Puedes seguir usando Docker localmente

**Para operadores de clusters:**
- ⚠️ Necesitas usar containerd o CRI-O
- ✅ Mejor rendimiento
- ✅ Menos recursos necesarios

## Línea de Tiempo

```
2013 - Docker lanzado
2014 - Kubernetes lanzado (usa Docker)
2016 - CRI introducido en Kubernetes 1.5
2017 - containerd donado a CNCF
2019 - containerd se gradúa en CNCF
2020 - dockershim deprecado (K8s 1.20)
2022 - dockershim eliminado (K8s 1.24)
2023+ - containerd como estándar
```

## Comandos Equivalentes

### Ver contenedores

```bash
# Con Docker
docker ps

# Con containerd (usando crictl)
crictl ps

# Con containerd (usando ctr)
ctr containers ls
```

### Ver imágenes

```bash
# Con Docker
docker images

# Con containerd (usando crictl)
crictl images

# Con containerd (usando ctr)
ctr images ls
```

## Mejores Prácticas para Kubernetes

### 1. Usa containerd en Producción
- Motor oficial y recomendado
- Mejor rendimiento
- Menos overhead

### 2. Mantén Docker para Desarrollo
- Mejor experiencia de usuario
- Docker Compose
- Herramientas familiares

### 3. Usa Imágenes OCI
- Compatibles con cualquier runtime
- Portables
- Estandarizadas

### 4. Considera CRI-O para Casos Específicos
- Entornos solo Kubernetes
- Red Hat/OpenShift
- Máxima simplicidad

## Conclusión

La transición a containerd como motor por defecto representa:

✅ **Ventajas:**
- Mejor rendimiento
- Arquitectura más simple
- Menor consumo de recursos
- Interfaz nativa con Kubernetes

✅ **Compatibilidad:**
- Total compatibilidad con imágenes Docker
- Estándares OCI
- Sin cambios en workflows de desarrollo

✅ **Futuro:**
- containerd es el estándar de facto
- Respaldo de CNCF
- Amplia adopción en la industria

Docker sigue siendo fundamental para desarrollo y construcción de imágenes, mientras que containerd es el motor preferido para ejecución en entornos de producción orquestados por Kubernetes.
