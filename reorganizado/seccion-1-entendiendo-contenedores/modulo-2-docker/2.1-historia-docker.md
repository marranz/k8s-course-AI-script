# 2.1 Historia y Orígenes de Docker

## ¿Qué es Docker?

Docker es más que una herramienta para crear contenedores aislados. Es una **plataforma completa** que revolucionó cómo empaquetar, distribuir y ejecutar aplicaciones. Combina:
- Tecnología de aislamiento de procesos (no inventada por ellos)
- Un ecosistema para compartir imágenes
- Herramientas accesibles y fáciles de usar
- Un estándar que cambió la industria

Sin Docker, los contenedores habrían seguido siendo una tecnología nicho. Con Docker, se convirtieron en el estándar de facto del desarrollo moderno.

## Los Antecedentes: Tecnologías Previas

La idea de aislar procesos y recursos del sistema es mucho más antigua que Docker:

- **chroot** (años 70): Herramienta Unix básica para cambiar el directorio raíz de un proceso
- **Jails** en FreeBSD (años 90): Sistema más sofisticado de aislamiento
- **LXC (Linux Containers)** (2008): Contenedores Linux completos, pero complejos de usar


El problema: **estas tecnologías funcionaban, pero eran difíciles de usar si no tenias conocimientos produndos de sistemas operativos y no tenían un ecosistema para compartir aplicaciones empaquetadas**. Cada organización debía resolver el problema desde cero.

## Los Inicios: dotCloud (2008)

Docker nació como un proyecto interno de la startup francesa **dotCloud** en 2008. La necesidad era clara:
- Alojaban aplicaciones de múltiples clientes en la misma infraestructura
- Necesitaban aislar los procesos de cada cliente de forma segura y sencilla
- Pero los sabían que la tecnología existente (LXC) era demasiado compleja

Inicialmente utilizaban LXC como base, pero lo envolvieron en una capa de abstracción que lo hacía mucho más accesible.

## El Punto de Inflexión: 2012

Para 2012, Docker se había refinado tanto que decidieron **liberar el proyecto como código abierto**. El impacto fue inmediato:

1. La comunidad adoptó Docker masivamente
2. La startup **dotCloud fue renombrada a Docker Inc.**
3. Su modelo de negocio pasó a girar completamente alrededor de Docker

## ¿Por Qué Docker Fue Diferente?

Mientras que LXC y otras soluciones existían, Docker triunfó porque aportó:

**1. Simplicidad**
- Comandos intuitivos: `docker build`, `docker run`, `docker push`
- Documentación accesible
- Curva de aprendizaje mucho menor

**2. Portabilidad**
- El concepto de **imagen**: un paquete completo y reproducible
- "Build once, run anywhere" - la misma imagen funciona en tu laptop, en CI/CD, en producción

**3. Ecosistema**
- **Docker Hub**: repositorio centralizado para compartir imágenes
- Comunidad masiva
- Herramientas complementarias

**4. Abstracción sobre LXC**
- Ocultaba la complejidad de los contenedores Linux
- Permitía que desarrolladores (no solo DevOps) usaran contenedores

Esto transformó los contenedores de una tecnología nicho a una herramienta fundamental en el desarrollo moderno de software.

## La Estandarización: OCI (2015-Presente)

Para entender Kubernetes y la evolución de Docker, hay que conocer lo que pasó después del "boom" inicial.

### El Problema: Riesgo de Monopolio

Cuando Docker dominaba completamente el mundo de los contenedores (2013-2015), surgió una preocupación en la industria:
- ¿Qué pasaba si Docker Inc. decidía "cerrar" la plataforma?
- ¿Qué pasaba si Kubernetes quería usar contenedores sin depender de Docker?

### La Solución: Open Container Initiative (OCI) - 2015

La industria (Google, Red Hat, Docker Inc. y otros) creó la **Open Container Initiative** para estandarizar:

- **Formato de imagen OCI**: Especificación abierta de cómo empaquetar una aplicación
- **Runtime OCI**: Especificación abierta de cómo ejecutar un contenedor
- **runc**: Implementación de referencia del runtime OCI

Docker "donó" su código base como contribución a estos estándares. **El resultado**: cualquiera podía construir contenedores sin depender de las herramientas de Docker.

### La Arquitectura Moderna: De Monolito a Componentes

Docker evolucionó de ser una herramienta monolítica a una arquitectura modular:

```
Docker (antes) = Todo integrado en un único programa
Docker (después) = Componentes independientes
```

Los componentes clave:

- **Docker CLI**: La interfaz que usas (`docker build`, `docker run`)
- **containerd**: Runtime de alto nivel que gestiona el ciclo de vida del contenedor
  - Descarga imágenes, crea contenedores, los ejecuta
  - **Este es el componente que usa Kubernetes hoy en día**
- **runc**: Runtime de bajo nivel que interactúa directamente con el Kernel de Linux

### Hitos Clave: De Docker a Kubernetes

- **2015**: Lanzamiento de Kubernetes 1.0, fundación de la CNCF, creación de OCI
- **2016**: Docker extrae `containerd` como proyecto independiente
- **2020**: Kubernetes **anuncia la deprecación de `dockershim`** (el componente que permitía usar "Docker completo")
  - Ahora Kubernetes usa directamente `containerd` o `CRI-O` (runtimes compatibles con CRI)

### Lo Más Importante

> **Las imágenes que construyes con `docker build` siguen funcionando perfectamente en Kubernetes**, gracias al estándar OCI. No necesitas cambiar tu flujo de trabajo.
