# 2.4 Docker Compose: Orquestación Local de Múltiples Contenedores

## ¿Por qué Docker Compose?

Las aplicaciones a menudo están compuestas por múltiples servicios interconectados. Por ejemplo:
- Un servicio que sirve la página web
- Otro que aloja una base de datos

Para poder ejecutar estos entornos multi contenedores de una forma sencilla podemos usar **Docker Compose**. Docker Compose nos permite:
- Definir estos contenedores y su configuración en un fichero de texto YAML
- Con comandos sencillos poder arrancar, parar o eliminar entornos completos

## Estructura de un Docker Compose

Un archivo `docker-compose.yml` típico tiene la siguiente estructura:

```yaml
version: '3.8'

services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html
    networks:
      - frontend
    depends_on:
      - api

  api:
    build: ./api
    ports:
      - "3000:3000"
    environment:
      - DB_HOST=database
      - DB_PORT=5432
    networks:
      - frontend
      - backend
    depends_on:
      - database

  database:
    image: postgres:14
    environment:
      - POSTGRES_PASSWORD=secreto
      - POSTGRES_DB=miapp
    volumes:
      - db-data:/var/lib/postgresql/data
    networks:
      - backend

networks:
  frontend:
  backend:

volumes:
  db-data:
```

## Ciclo de Vida con Docker Compose

### Comandos Básicos

#### docker compose up
Crear e iniciar todos los servicios
```bash
# Iniciar en primer plano
docker compose up

# Iniciar en segundo plano (detached)
docker compose up -d

# Reconstruir imágenes antes de iniciar
docker compose up --build

# Iniciar solo un servicio específico
docker compose up web
```

#### docker compose down
Detener y eliminar contenedores, redes
```bash
# Detener y eliminar contenedores y redes
docker compose down

# También eliminar volúmenes
docker compose down -v

# También eliminar imágenes
docker compose down --rmi all
```

#### docker compose stop
Detener servicios sin eliminarlos
```bash
docker compose stop
docker compose stop web
```

#### docker compose start
Iniciar servicios previamente detenidos
```bash
docker compose start
docker compose start web
```

#### docker compose restart
Reiniciar servicios
```bash
docker compose restart
docker compose restart api
```

### Comandos de Gestión

```bash
# Ver logs
docker compose logs
docker compose logs -f  # Seguir logs en tiempo real
docker compose logs web # Logs de un servicio específico

# Listar contenedores
docker compose ps

# Ejecutar un comando en un servicio
docker compose exec web sh
docker compose exec database psql -U postgres

# Ver configuración procesada
docker compose config
```

## Crear una Imagen con Docker Compose

Docker Compose puede construir imágenes automáticamente usando Dockerfiles:

```yaml
services:
  api:
    build:
      context: ./api
      dockerfile: Dockerfile
      args:
        - NODE_ENV=production
    image: mi-api:latest
```

**Construir las imágenes:**
```bash
docker compose build
docker compose build api  # Solo un servicio
```

## Persistencia en Docker Compose

### Volúmenes Nombrados

```yaml
services:
  database:
    image: postgres
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:
```

### Bind Mounts

```yaml
services:
  web:
    image: nginx
    volumes:
      - ./html:/usr/share/nginx/html
      - ./nginx.conf:/etc/nginx/nginx.conf:ro  # read-only
```

## Red en Docker Compose

Docker Compose crea automáticamente una red por defecto para todos los servicios, permitiendo que se comuniquen usando sus nombres de servicio.

### Redes Personalizadas

```yaml
services:
  web:
    networks:
      - frontend

  api:
    networks:
      - frontend
      - backend

  database:
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  # No acceso externo
```

## Ejemplo Completo: Aplicación Web con Base de Datos

### Estructura del Proyecto
```
mi-proyecto/
├── docker-compose.yml
├── web/
│   ├── Dockerfile
│   └── index.html
└── api/
    ├── Dockerfile
    ├── app.js
    └── package.json
```

### docker-compose.yml
```yaml
version: '3.8'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./web:/usr/share/nginx/html
    depends_on:
      - api
    networks:
      - frontend

  api:
    build: ./api
    ports:
      - "3000:3000"
    environment:
      DB_HOST: postgres
      DB_USER: usuario
      DB_PASS: password
      DB_NAME: miapp
    depends_on:
      - postgres
    networks:
      - frontend
      - backend
    restart: unless-stopped

  postgres:
    image: postgres:14-alpine
    environment:
      POSTGRES_USER: usuario
      POSTGRES_PASSWORD: password
      POSTGRES_DB: miapp
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - backend
    restart: unless-stopped

networks:
  frontend:
  backend:

volumes:
  postgres-data:
```

### Comandos para el Ejemplo

```bash
# Iniciar todo el stack
docker compose up -d

# Ver logs de todos los servicios
docker compose logs -f

# Escalar un servicio (crear múltiples instancias)
docker compose up -d --scale api=3

# Acceder a la base de datos
docker compose exec postgres psql -U usuario -d miapp

# Detener todo
docker compose down

# Detener y eliminar todo incluyendo volúmenes
docker compose down -v
```

## Variables de Entorno

### Archivo .env
```env
POSTGRES_VERSION=14
API_PORT=3000
POSTGRES_PASSWORD=mi_secreto
```

### Usar en docker-compose.yml
```yaml
services:
  postgres:
    image: postgres:${POSTGRES_VERSION}
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}

  api:
    ports:
      - "${API_PORT}:3000"
```

## Mejores Prácticas

1. **Usa versiones específicas de imágenes** - evita `latest` en producción
2. **Define depends_on** para gestionar el orden de inicio
3. **Usa health checks** para asegurar que los servicios están listos
4. **Externaliza configuración** con variables de entorno
5. **Usa volúmenes nombrados** para datos importantes
6. **Documenta tu docker-compose.yml** con comentarios
7. **Separa configuraciones** (desarrollo, producción) con múltiples archivos:
   ```bash
   docker compose -f docker-compose.yml -f docker-compose.prod.yml up
   ```
