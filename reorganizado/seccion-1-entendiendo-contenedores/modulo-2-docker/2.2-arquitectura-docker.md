# 2.2 Arquitectura de Docker

Docker utiliza una arquitectura **cliente-servidor**. El demonio de Docker (Docker Daemon) está a la escucha de peticiones de cambios y hace el trabajo pesado de construir, ejecutar y comprobar el estado de los contenedores.

El cliente de Docker (Docker CLI) hace de intermediario entre el usuario y el demonio de Docker, enviando las peticiones a través de una **API REST** del Docker Daemon.

Nosotros interactuaremos con el cliente de Docker (Docker CLI) para gestionar nuestros contenedores, indicándole mediante diferentes comandos qué queremos hacer en cada momento: crear, eliminar, listar, etc.


## 1. El Modelo Cliente-Servidor

### El Cliente (Docker CLI)
Es la herramienta `docker` que usas en la terminal.
-   Cuando ejecutas `docker build` o `docker run`, el cliente no hace el trabajo real.
-   Envía una petición a la **API REST** del Docker Daemon.

### El Host (Docker Daemon - `dockerd`)
Es el proceso persistente que corre en segundo plano en el servidor.
-   Escucha las peticiones de la API.
-   Gestiona los objetos de Docker (imágenes, contenedores, redes, volúmenes).

### El Canal de Comunicación: Docker Socket
La comunicación entre Cliente y Daemon ocurre, por defecto, a través de un **Socket Unix** (`/var/run/docker.sock`).
> **Nota de Seguridad**: Quien tenga acceso a este socket tiene acceso de `root` al sistema, ya que puede crear contenedores privilegiados.

Esta arquitectura permite que el cliente y el servidor corran en diferentes máquinas, lo que es especialmente útil para el despliegue de contenedores en servidores remotos.
---

## 2. El Motor Interno: ¿Cómo funciona realmente?

Antiguamente `dockerd` era un monolito. Hoy en día, delega en componentes especializados (siguiendo la filosofía UNIX):

1.  **dockerd**: Recibe la petición de la API (ej. "crear contenedor").
2.  **containerd**: Gestiona el ciclo de vida (descarga la imagen, prepara el almacenamiento).
3.  **runc**: Interactúa con el Kernel (Namespaces/Cgroups) para crear el proceso aislado.
4.  **shim**: Un proceso ligero que se queda "pegado" al contenedor para mantenerlo vivo y recoger su código de salida, permitiendo que `dockerd` pueda reiniciarse sin matar los contenedores.

---

## 3. Objetos Principales de Docker

### Imágenes y el Sistema de Capas (Layers)
Una imagen no es un archivo único, es un conjunto de **capas de solo lectura** apiladas.
-   Docker usa un **Union File System (UnionFS)** (generalmente `overlay2`) para combinar estas capas en una sola vista unificada del sistema de archivos.
-   **Eficiencia de Almacenamiento**: Si tienes 10 imágenes basadas en `ubuntu`, solo se almacena la capa de `ubuntu` una vez en disco y se comparte entre todas las imágenes.
-   **Copy-on-Write (CoW)**: Cuando necesitas modificar un archivo en una capa inferior, el sistema crea una copia en la capa de escritura sin afectar la capa original de solo lectura.

### Contenedores (La Capa de Escritura)
Cuando arrancas un contenedor, Docker toma las capas de la imagen (solo lectura) y añade una **fina capa de escritura (Read/Write Layer)** encima.
-   Cualquier cambio que hace el contenedor se escribe en esta capa efímera.
-   Si borras el contenedor, esta capa se pierde (por eso los contenedores son efímeros por defecto).

### Volúmenes (Persistencia)
Para guardar datos más allá de la vida del contenedor, usamos **Volúmenes**.
-   Son directorios gestionados por Docker en el host.
-   Se "montan" dentro del contenedor.
-   Sobreviven al borrado del contenedor.

### Redes (Networking - CNM: Container Network Model)
Docker implementa el **Container Network Model (CNM)** para conectar contenedores:
-   **Bridge** (predeterminada): Los contenedores se ven entre sí por nombre de contenedor o IP dentro de la red bridge.
-   **Host**: El contenedor comparte la pila de red del host (sin aislamiento de red). Útil para máxima performance.
-   **None**: El contenedor no tiene interfaz de red (aislamiento total).
-   **Overlay**: Para conectar contenedores en diferentes hosts (usado en Docker Swarm y orquestadores como Kubernetes).

---

## 4. El Registro (Docker Hub)

El registro es el almacén centralizado de imágenes.
-   **Docker Hub** es el registro público por defecto.
-   Cuando haces `docker pull`, el daemon pide las capas necesarias al registro.

---

## 5. Por qué Kubernetes No Necesita Docker (La Arquitectura Modular)

Uno de los puntos clave para entender por qué Kubernetes puede usar `containerd` directamente sin `dockerd`:

-   **Docker es una abstracción**: `dockerd` es un nivel de abstracción sobre `containerd` y `runc`.
-   **Kubernetes necesita bajo nivel**: K8s necesita controlar directamente `containerd` (el gestor del ciclo de vida de contenedores).
-   **Modularidad UNIX**: La arquitectura modular permite a otros orquestadores (Kubernetes, Podman, etc.) usar `runc` y `containerd` sin depender de Docker.

En resumen:
- **Docker CLI** → **dockerd** → **containerd** → **runc** (Arquitectura Docker tradicional)
- **Kubernetes** → **containerd** → **runc** (Kubernetes puede saltarse dockerd)
