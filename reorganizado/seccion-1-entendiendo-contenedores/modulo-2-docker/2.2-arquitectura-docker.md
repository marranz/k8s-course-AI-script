# 2.2 Arquitectura de Docker

Docker utiliza una arquitectura **cliente-servidor**. El demonio de Docker (Docker Daemon) está a la escucha de peticiones de cambios y hace el trabajo pesado de construir, ejecutar y comprobar el estado de los contenedores.

El cliente de Docker (Docker CLI) hace de intermediario entre el usuario y el demonio de Docker, enviando las peticiones a través de una **API REST** del Docker Daemon.

Nosotros interactuaremos con el cliente de Docker (Docker CLI) para gestionar nuestros contenedores, indicándole mediante diferentes comandos qué queremos hacer en cada momento: crear, eliminar, listar, etc.


## 1. El Modelo Cliente-Servidor

### El Cliente (Docker CLI)
Es la herramienta `docker` que usas en la terminal.
-   Cuando ejecutas `docker build` o `docker run`, el cliente no hace el trabajo real.
-   Envía una petición a la **API REST** del Docker Daemon.

### El Host (Docker Daemon - `dockerd`)
Es el proceso persistente que corre en segundo plano en el servidor.
-   Escucha las peticiones de la API.
-   Gestiona los objetos de Docker (imágenes, contenedores, redes, volúmenes).

### El Canal de Comunicación: Docker Socket
La comunicación entre Cliente y Daemon ocurre, por defecto, a través de un **Socket Unix** (`/var/run/docker.sock`).
> **Nota de Seguridad**: Quien tenga acceso a este socket tiene acceso de `root` al sistema, ya que puede crear contenedores privilegiados.

Esta arquitectura permite que el cliente y el servidor corran en diferentes máquinas, lo que es especialmente útil para el despliegue de contenedores en servidores remotos.
---

## 2. El Motor Interno: ¿Cómo funciona realmente?

Antiguamente `dockerd` era un monolito. Hoy en día, delega en componentes especializados (siguiendo la filosofía UNIX):

1.  **dockerd**: Recibe la petición de la API (ej. "crear contenedor").
2.  **containerd**: Gestiona el ciclo de vida (descarga la imagen, prepara el almacenamiento).
3.  **runc**: Interactúa con el Kernel (Namespaces/Cgroups) para crear el proceso aislado.
4.  **shim**: Un proceso ligero que se queda "pegado" al contenedor para mantenerlo vivo y recoger su código de salida, permitiendo que `dockerd` pueda reiniciarse sin matar los contenedores.

---

## 3. Objetos Principales de Docker

### Imágenes y el Sistema de Capas (Layers)
Una imagen no es un archivo único, es un conjunto de **capas de solo lectura** apiladas.
-   Docker usa un **Union File System (UnionFS)** (generalmente `overlay2`) para combinar estas capas en una sola vista unificada del sistema de archivos.
-   **Eficiencia de Almacenamiento**: Si tienes 10 imágenes basadas en `ubuntu`, solo se almacena la capa de `ubuntu` una vez en disco y se comparte entre todas las imágenes.
-   **Copy-on-Write (CoW)**: Cuando necesitas modificar un archivo en una capa inferior, el sistema crea una copia en la capa de escritura sin afectar la capa original de solo lectura.

**Inspeccionar capas en la práctica:**
```bash
docker inspect <imagen>  # Muestra todas las capas (SHA256) de una imagen
docker history <imagen>  # Muestra cada instrucción del Dockerfile que creó cada capa
```
Esto es útil para entender por qué una imagen pesa lo que pesa y optimizarla.

### Contenedores (La Capa de Escritura)
Cuando arrancas un contenedor, Docker toma las capas de la imagen (solo lectura) y añade una **fina capa de escritura (Read/Write Layer)** encima.
-   Cualquier cambio que hace el contenedor se escribe en esta capa efímera.
-   Si borras el contenedor, esta capa se pierde (por eso los contenedores son efímeros por defecto).

### Volúmenes (Persistencia)
Para guardar datos más allá de la vida del contenedor, usamos **Volúmenes**. Docker ofrece varios tipos:

**1. Volúmenes Gestionados por Docker** (recomendado)
-   Docker los gestiona automáticamente en `/var/lib/docker/volumes/`
-   Son el método más seguro y portable.
-   Se crean con `docker volume create <nombre>` o automáticamente cuando un contenedor los necesita.

**2. Bind Mounts** (montar directorios del host)
-   Montas un directorio específico del host dentro del contenedor.
-   Útil en desarrollo para reflejar cambios en tiempo real.
-   Menos portátil que los volúmenes gestionados (dependen de la estructura del host).

**3. tmpfs Mounts** (almacenamiento en memoria)
-   Los datos se guardan en la RAM del host, no en disco.
-   Muy rápido pero se pierde al parar el contenedor.
-   Útil para datos sensibles o caché temporal.

**Características comunes:**
-   Sobreviven al borrado del contenedor (excepto tmpfs).
-   Pueden ser compartidos entre múltiples contenedores.
-   Se "montan" dentro del contenedor en cualquier ruta.

### Redes (Networking - CNM: Container Network Model)
Docker implementa el **Container Network Model (CNM)** para conectar contenedores. Cada tipo tiene un caso de uso específico:

-   **Bridge** (predeterminada): Los contenedores se ven entre sí por nombre de contenedor o IP dentro de la red bridge.
    - Caso de uso: Aplicaciones multi-contenedor en el mismo host (Docker Compose local).

-   **Host**: El contenedor comparte la pila de red del host (sin aislamiento de red).
    - Caso de uso: Máxima performance (bases de datos, reverse proxies, servicios de red críticos).
    - Desventaja: No hay aislamiento, el contenedor ve todos los puertos del host.

-   **None**: El contenedor no tiene interfaz de red (aislamiento total).
    - Caso de uso: Contenedores que solo procesan datos sin necesidad de red (batch jobs, workers offline).

-   **Overlay**: Para conectar contenedores en diferentes hosts.
    - Caso de uso: Docker Swarm, Kubernetes y otros orquestadores de cluster.
    - Crea una red virtual encriptada entre nodos.

---

## 4. El Registro (Docker Hub y Registros Privados)

El registro es el almacén centralizado de imágenes que el Docker Daemon consulta cuando necesitas descargar una imagen que no tienes localmente.

-   **Docker Hub** (hub.docker.com): El registro público oficial.
    - Contiene imágenes públicas (oficiales y de usuarios).
    - Cuando haces `docker pull ubuntu`, Docker trae la imagen de Hub.

-   **Registros Privados**: Empresas y equipos usan registros propios.
    - Docker Registry (open source) o soluciones gestionadas (AWS ECR, Google Artifact Registry, GitLab Container Registry).
    - Útil para guardar imágenes internas sin exponerlas públicamente.

**Flujo de descarga:**
1. Ejecutas `docker pull myimage:latest`
2. El Daemon consulta el registro (Docker Hub por defecto)
3. El Daemon descarga las capas necesarias
4. Las capas se almacenan en `/var/lib/docker/image/`
5. Se construye la imagen a partir de las capas

---

## 5. Por qué Kubernetes No Necesita Docker (La Arquitectura Modular)

Uno de los puntos clave para entender por qué Kubernetes puede usar `containerd` directamente sin `dockerd`:

-   **Docker es una abstracción**: `dockerd` es un nivel de abstracción sobre `containerd` y `runc`.
-   **Kubernetes necesita bajo nivel**: K8s necesita controlar directamente `containerd` (el gestor del ciclo de vida de contenedores).
-   **Modularidad UNIX**: La arquitectura modular permite a otros orquestadores (Kubernetes, Podman, etc.) usar `runc` y `containerd` sin depender de Docker.

En resumen:
- **Docker CLI** → **dockerd** → **containerd** → **runc** (Arquitectura Docker tradicional)
- **Kubernetes** → **containerd** → **runc** (Kubernetes puede saltarse dockerd)
