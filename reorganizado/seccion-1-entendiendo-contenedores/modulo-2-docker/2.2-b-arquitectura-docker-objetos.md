# 2.2 Arquitectura de Docker - Objetos Principales

## Slide 1

Seguimos con la arquitectura de docker pero ahora desde el punto de vista de los objectos.


## Slide 2

#### Imágenes y el Sistema de Capas (Layers)
Una imagen, como hemos dicho, no es un archivo único, es un conjunto de **capas de solo lectura** apiladas.

-   Docker usa un **Union File System (UnionFS)** para combinar estas capas en una sola vista unificada del sistema de archivos. Esto lo realiza containerd. Generalmente usa una implementacion de UnionFS conocida como `overlay2`.

-   **Eficiencia de Almacenamiento**: Si tienes 10 imágenes basadas en `ubuntu`, solo se almacena la capa de `ubuntu` una vez en disco y se comparte entre todas las imágenes.
## Slide 2

Aqui vemos lo que sucede cuando queremos modificar algo en una capa inicial. 

Como las capas son de solo lectura, creamos los ficheros modificados en una capa nueva. 

## Slide 3
### Contenedores (La Capa de Escritura)
Cuando arrancas un contenedor, Docker toma las capas de la imagen (solo lectura) y añade una **fina capa de escritura (Read/Write Layer)** encima.
-   Cualquier cambio que hace el contenedor se escribe en esta capa efímera.
-   Si borras el contenedor, esta capa se pierde (por eso los contenedores son efímeros por defecto).

# Slide 4
### Volúmenes (Persistencia)
Como hemos dicho lo contenedores no persiten datos. Cuando un contendor finaliza, todos los datos que se crearon en el contenedor se pierden.

Para guardar datos más allá de la vida del contenedor, usamos **Volúmenes**. Docker ofrece varios tipos:

**1. Volúmenes Gestionados por Docker** (recomendado)
- Docker los gestiona automáticamente en `/var/lib/docker/volumes/`
- Son el método más seguro y portable.
- Se crean con `docker volume create <nombre>` o automáticamente cuando un contenedor los necesita.

**2. Bind Mounts** (montar directorios del host)
-   Montas un directorio específico del host dentro del contenedor.
-   Útil en desarrollo para reflejar cambios en tiempo real.
-   Menos portátil que los volúmenes gestionados (dependen de la estructura del host).

**3. tmpfs Mounts** (almacenamiento en memoria)
-   Los datos se guardan en la RAM del host, no en disco.
-   Muy rápido pero se pierde al parar el contenedor.
-   Útil para datos sensibles o caché temporal.

**Características comunes:**
-   Sobreviven al borrado del contenedor (excepto tmpfs).
-   Pueden ser compartidos entre múltiples contenedores.
-   Se "montan" dentro del contenedor en cualquier ruta.

### Redes (Networking - CNM: Container Network Model)
Docker implementa el **Container Network Model (CNM)** para conectar contenedores. Cada tipo tiene un caso de uso específico:

-   **Bridge** (predeterminada): Los contenedores se ven entre sí por nombre de contenedor o IP dentro de la red bridge.
    - Caso de uso: Aplicaciones multi-contenedor en el mismo host (Docker Compose local).

-   **Host**: El contenedor comparte la pila de red del host (sin aislamiento de red).
    - Caso de uso: Máxima performance (bases de datos, reverse proxies, servicios de red críticos).
    - Desventaja: No hay aislamiento, el contenedor ve todos los puertos del host.

-   **None**: El contenedor no tiene interfaz de red (aislamiento total).
    - Caso de uso: Contenedores que solo procesan datos sin necesidad de red (batch jobs, workers offline).

-   **Overlay**: Para conectar contenedores en diferentes hosts.
    - Caso de uso: Docker Swarm, Kubernetes y otros orquestadores de cluster.
    - Crea una red virtual encriptada entre nodos.

---

## 4. El Registro (Docker Hub y Registros Privados)

El registro es el almacén centralizado de imágenes que el Docker Daemon consulta cuando necesitas descargar una imagen que no tienes localmente.

-   **Docker Hub** (hub.docker.com): El registro público oficial.
    - Contiene imágenes públicas (oficiales y de usuarios).
    - Cuando haces `docker pull ubuntu`, Docker trae la imagen de Hub.

-   **Registros Privados**: Empresas y equipos usan registros propios.
    - Docker Registry (open source) o soluciones gestionadas (AWS ECR, Google Artifact Registry, GitLab Container Registry).
    - Útil para guardar imágenes internas sin exponerlas públicamente.

**Flujo de descarga:**
1. Ejecutas `docker pull myimage:latest`
2. El Daemon consulta el registro (Docker Hub por defecto)
3. El Daemon descarga las capas necesarias
4. Las capas se almacenan en `/var/lib/docker/image/`
5. Se construye la imagen a partir de las capas

---

## 5. Por qué Kubernetes No Necesita Docker (La Arquitectura Modular)

Uno de los puntos clave para entender por qué Kubernetes puede usar `containerd` directamente sin `dockerd`:

-   **Docker es una abstracción**: `dockerd` es un nivel de abstracción sobre `containerd` y `runc`.
-   **Kubernetes necesita bajo nivel**: K8s necesita controlar directamente `containerd` (el gestor del ciclo de vida de contenedores).
-   **Modularidad UNIX**: La arquitectura modular permite a otros orquestadores (Kubernetes, Podman, etc.) usar `runc` y `containerd` sin depender de Docker.

En resumen:
- **Docker CLI** → **dockerd** → **containerd** → **runc** (Arquitectura Docker tradicional)
- **Kubernetes** → **containerd** → **runc** (Kubernetes puede saltarse dockerd)
