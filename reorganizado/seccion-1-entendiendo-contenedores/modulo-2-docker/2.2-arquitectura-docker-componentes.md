# 2.2 Arquitectura de Docker

## Slide 1

En este video vamos a hablar de la arquitectura de Docker. y algunos de los componentes que componen esta arquitectura.

## Slide 2

Docker utiliza una modelo de arquitectura **cliente-servidor**. El demonio de Docker (Docker Daemon) está a la escucha de peticiones de cambios y hace el trabajo pesado de construir, ejecutar y comprobar el estado de los contenedores.

El cliente de Docker (Docker CLI) hace de intermediario entre el usuario y el demonio de Docker, enviando las peticiones a través de una **API REST** del Docker Daemon.

Nosotros interactuaremos con el cliente de Docker (Docker CLI) para gestionar nuestros contenedores, indicándole mediante diferentes comandos qué queremos hacer en cada momento: crear, eliminar, listar, etc.


## Slide 3


### El Cliente (Docker CLI)
Es la herramienta `docker` que usas en la terminal.
-   Cuando ejecutas `docker build` o `docker run`, el cliente no hace el trabajo real.
-   Envía una petición a la **API REST** del Docker Daemon.

### El Host (Docker Daemon - `dockerd`)
Es el proceso persistente que corre en segundo plano en el servidor.
-   Escucha las peticiones via su API REST.
-   Gestiona los objetos de Docker (imágenes, contenedores, redes, volúmenes), a traves de otros componentes.

## Slide 4

### El Canal de Comunicación: Docker Socket
La comunicación entre Cliente y Daemon ocurre, por defecto, a través de un **Socket Unix** (`/var/run/docker.sock`)

Por lo tanto todos los usuarios que necesiten comunicarse con el demonio de Docker tendrán que tener acceso a este socket.

> **Nota de Seguridad**: Quien tenga acceso a este socket tiene acceso de `root` al sistema, ya que puede crear contenedores privilegiados.

Esta arquitectura permite que el cliente y el servidor corran en diferentes máquinas, lo que es especialmente útil para el despliegue de contenedores en servidores remotos.
---
## Slide 5

### El Motor Interno: ¿Cómo funciona realmente?

Antiguamente `dockerd` era un monolito. Es decir, era un solo proceso que hacia todas las tareas que hemos mencionado. 

Hoy en día, delega en componentes especializados, siguiendo un modelo de arquitectura mas moderno, modular y escalable.

Aqui vemos que nuestro CLI habla con Docker daemon, este con containerd, este interactua con el kernel a traves de runc, y por ultimo shim se encargar de mantener el contenedor levantado.

En una arquitectura de servidor, es posible que algunos de estos componentes no esten. Por ejemplo, si usamos kubernetes, no tendremos dockerd, puesto que los componentes de kubernetes hablan directamente con containerd.

Alugnos componentes, como containerd pueden ser sustituidos por otros quivalente, siempre y cuando cumplan cumplan con la normativa CRI, como cri-o o Podman

# slide 6

1.  **dockerd**: Recibe la petición via API REST (ej. "crear contenedor"). Crea imagenes, descargando capas si fuera necesario cuano ejecutamos un comando tipo docker pull o docker buil. Algunas de estas tareas sond elegadas a containerd, otras lsa realiza dockerd directamente para descargar de trabajo a containerd. Tambien prepara volumenes, configura la red, etc

Es un poco complejo entender que tareas hace dockerd y cuales containerd. Por ejemplo, en la gestion de imagenes:

si hacemos un docker pull, dockerd descarga delega esta tarea a containerd, pero si hacemos un docker build, dockerd se encarga de descargar las capas de la imagen, y containerd se encarga de construir la imagen final. Un poco lio, lo se. 

Si nos logueamos aun registro remoto para descargar una imagen o subirlas, dockerd se encarga de autenticar con el registro remoto, y containerd se encarga de descargar la imagen.

En cuanto a tareas de red, dockerd puede gestionar los motores de red, asociar ips, crea los interaces y gestionar la resolucion DNS, mientras que containerd hace tareas a mas bajo nivel, como configurar el network namespace, adjunta los interfaces de red a el contenedor, etc. 

2.  **containerd**: Gestiona el ciclo de vida del contenedor, es decir: arrancarlo, pararlo, eliminarlo, etc. y tambien Configura ciertas tareas de red especificas de mas bajo nivel. 

3.  **runc**: Interactúa con el Kernel (Namespaces/Cgroups) para crear el proceso aislado y fijar el limite de recursos. No realiza apenas tareas de red ni de gestion de imagenes. 

4.  **shim**: Un proceso ligero que se queda "pegado" al contenedor para mantenerlo vivo gestiona su estado. Asi podriamos reiniciar containerd y dockerd sin problema, que cuando vuelvan a estar activos, el contenedor seguira vivo sin haber sufrido ningun daño. Ademas es el proceso que se encarga de recoger la salida del contenedor para detectar si sigue vivo y gestionar los logs de salida.
